{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the LLVM Wiki!","title":"LLVM Wiki"},{"location":"#welcome-to-the-llvm-wiki","text":"","title":"Welcome to the LLVM Wiki!"},{"location":"index.zh/","text":"\u6b22\u8fce\u8bbf\u95ee LLVM Wiki!","title":"LLVM Wiki"},{"location":"index.zh/#\u6b22\u8fce\u8bbf\u95ee-llvm-wiki","text":"","title":"\u6b22\u8fce\u8bbf\u95ee LLVM Wiki!"},{"location":"llvm/pass/","text":"Pass The LLVM pass framework is an important part of the LLVM system, because LLVM passes are where the most interesting parts of the compiler exist. Passes perform transformations and optimizations that make up the compiler, they build the analysis results that are used by these transformations, and they are, above all, a structuring technique for compiler code. An LLVM pass can be regarded as a black box that takes LLVM IR as input and produces outputs depending on what kind the pass is. There're two kinds of passes: transformation pass and analysis pass . For a transformation pass, it typically modifies the input IR and produces the transformed IR. Code generation passes that output SelectionDAG and machine IR from input LLVM IR are also transformation passes. For an analysis pass, it does not modify the input IR, but it looks into the IR and produces certain information that describes some properties about the input IR. Transformation passes typically implement compiler optimizations, program transformation, program instrumentation and other tasks. Analysis passes typically provide necessary information for the transformation passes to work. Real-world compilers usually rely on hundreds of passes that run one after another on the generated IR to complete optimization and code generation. This sequence of passes that run one after another is also called the pipeline . Note that different compiler configurations may end with different pipeline configurations, affecting the set of passes used and their execution order. Passes can have dependencies . For example, a transformation pass cannot work until its required analysis passes have been run. Also, some transformation passes can invalidate cached code properties analyzed by a previous analysis pass. LLVM uses pass managers to manage available passes and schedule the pass pipeline properly onto the input IR. Unfortunately, due to historical reasons, LLVM has two flavors of pass managers at now: the new pass manager and the legacy pass manager. This wiki primarily talks about the new pass manager, and the LLVM community is migrating to the new pass manager and deprecating the legacy one.","title":"llvm-pass-overview"},{"location":"llvm/pass/#pass","text":"The LLVM pass framework is an important part of the LLVM system, because LLVM passes are where the most interesting parts of the compiler exist. Passes perform transformations and optimizations that make up the compiler, they build the analysis results that are used by these transformations, and they are, above all, a structuring technique for compiler code. An LLVM pass can be regarded as a black box that takes LLVM IR as input and produces outputs depending on what kind the pass is. There're two kinds of passes: transformation pass and analysis pass . For a transformation pass, it typically modifies the input IR and produces the transformed IR. Code generation passes that output SelectionDAG and machine IR from input LLVM IR are also transformation passes. For an analysis pass, it does not modify the input IR, but it looks into the IR and produces certain information that describes some properties about the input IR. Transformation passes typically implement compiler optimizations, program transformation, program instrumentation and other tasks. Analysis passes typically provide necessary information for the transformation passes to work. Real-world compilers usually rely on hundreds of passes that run one after another on the generated IR to complete optimization and code generation. This sequence of passes that run one after another is also called the pipeline . Note that different compiler configurations may end with different pipeline configurations, affecting the set of passes used and their execution order. Passes can have dependencies . For example, a transformation pass cannot work until its required analysis passes have been run. Also, some transformation passes can invalidate cached code properties analyzed by a previous analysis pass. LLVM uses pass managers to manage available passes and schedule the pass pipeline properly onto the input IR. Unfortunately, due to historical reasons, LLVM has two flavors of pass managers at now: the new pass manager and the legacy pass manager. This wiki primarily talks about the new pass manager, and the LLVM community is migrating to the new pass manager and deprecating the legacy one.","title":"Pass"},{"location":"llvm/pass/hello-world/","text":"Write a Hello World Pass In this section, we guide you through writing and running a simple pass that prints the names of all functions contained in the input IR module. Setup the Build Let's assume that you have cloned the LLVM monorepo and setup the build directory at build/ 1 , and the current working directory is the root of the monorepo. In this section, we will build the new pass in-tree, which means that the source tree of the new pass is directly embedded in the source tree of the LLVM monorepo. Create a Hello.h file under llvm/include/llvm/Transforms/Utils/ : 1 touch llvm/include/llvm/Transforms/Utils/Hello.h Create a Hello.cpp file under llvm/lib/Transforms/Utils/ : 1 touch llvm/lib/Transforms/Utils/Hello.cpp Modify llvm/lib/Transforms/Utils/CMakeLists.txt and add Hello.cpp to the add_llvm_component_library call: 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) This step adds Hello.cpp to the LLVM build process. Code Implementation Edit Hello.h as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif Edit Hello.cpp as follows: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm Yes! This is (almost) all you need to write a simple but working pass. Let's break the code into pieces and see how it's working. To create a pass in C++, you need to write a class that implements the software interface of a pass. Unlike traditional approaches which rely on class inheritance, the new pass manager uses concepts-based polymorphism 2 3 . As long as the class contains a run method that allows it to run on some piece of IR, it is a pass . No need to inherit the class from some base class and override some virtual functions. In the code above, our HelloPass class inherits from the PassInfoMixin class, which adds some boilerplate code to the pass. But the most important part is the run method that makes HelloPass a pass. The run method takes two parameters. The first parameter F is the IR function that the pass is running on. Note that F is passed via a non-const reference, indicating that we can modify the function (i.e. perform transformations) in the pass. The second parameter AM is a pass manager instance that links to analysis passes and provides function-level analysis information. Since the run method takes Function as input, HelloPass is a function pass . The pass manager schedules a function pass to run on every function in the input IR module. When the HelloPass gets executed, it writes the function's name to the standard error and finishes. The run method returns a PreservedAnalyses object. This object contains information about whether the analysis performed by a previous analysis pass is still valid after this pass runs. The run method returns PreservedAnalyses::all() to indicate that all available analysis is still valid after running HelloPass (because it doesn't modify the IR). Register the Pass We have finished implementing the simple pass but we havn't told LLVM pass manager about the existance of our new pass. We need to register our new pass into the pass manager. Edit llvm/lib/Passes/PassRegistry.def and add the following lines to it: 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) Note the first argument to FUNCTION_PASS is the name of our new pass. Add the following #include to llvm/lib/Passes/PassBuilder.cpp : 1 #include \"llvm/Transforms/Utils/Hello.h\" and it's done. Now time for building and running our new pass. Build and Run Go to the build directory and build opt , which is a dedicated tool for running passes over a piece of IR. After building opt , create a test IR file test.ll for testing: 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } Then run our new pass with opt : 1 build/bin/opt -disable-output test.ll -passes = hello The -passes=hello option make opt run HelloPass . Expected output: 1 2 foo bar Congratulations! You have finished your LLVM pass! For instructions on how to build LLVM from source, please refer to the official documentation . \u21a9 You can refer to this comment for a brief introduction to the concepts-based polymorphism used in the pass framework. \u21a9 For a detailed introduction and discussion about concepts-based polymorphism, please refer to GuillaumeDua. Concept-based polymorphism in modern C++ . \u21a9","title":"Hello World"},{"location":"llvm/pass/hello-world/#write-a-hello-world-pass","text":"In this section, we guide you through writing and running a simple pass that prints the names of all functions contained in the input IR module.","title":"Write a Hello World Pass"},{"location":"llvm/pass/hello-world/#setup-the-build","text":"Let's assume that you have cloned the LLVM monorepo and setup the build directory at build/ 1 , and the current working directory is the root of the monorepo. In this section, we will build the new pass in-tree, which means that the source tree of the new pass is directly embedded in the source tree of the LLVM monorepo. Create a Hello.h file under llvm/include/llvm/Transforms/Utils/ : 1 touch llvm/include/llvm/Transforms/Utils/Hello.h Create a Hello.cpp file under llvm/lib/Transforms/Utils/ : 1 touch llvm/lib/Transforms/Utils/Hello.cpp Modify llvm/lib/Transforms/Utils/CMakeLists.txt and add Hello.cpp to the add_llvm_component_library call: 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) This step adds Hello.cpp to the LLVM build process.","title":"Setup the Build"},{"location":"llvm/pass/hello-world/#code-implementation","text":"Edit Hello.h as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif Edit Hello.cpp as follows: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm Yes! This is (almost) all you need to write a simple but working pass. Let's break the code into pieces and see how it's working. To create a pass in C++, you need to write a class that implements the software interface of a pass. Unlike traditional approaches which rely on class inheritance, the new pass manager uses concepts-based polymorphism 2 3 . As long as the class contains a run method that allows it to run on some piece of IR, it is a pass . No need to inherit the class from some base class and override some virtual functions. In the code above, our HelloPass class inherits from the PassInfoMixin class, which adds some boilerplate code to the pass. But the most important part is the run method that makes HelloPass a pass. The run method takes two parameters. The first parameter F is the IR function that the pass is running on. Note that F is passed via a non-const reference, indicating that we can modify the function (i.e. perform transformations) in the pass. The second parameter AM is a pass manager instance that links to analysis passes and provides function-level analysis information. Since the run method takes Function as input, HelloPass is a function pass . The pass manager schedules a function pass to run on every function in the input IR module. When the HelloPass gets executed, it writes the function's name to the standard error and finishes. The run method returns a PreservedAnalyses object. This object contains information about whether the analysis performed by a previous analysis pass is still valid after this pass runs. The run method returns PreservedAnalyses::all() to indicate that all available analysis is still valid after running HelloPass (because it doesn't modify the IR).","title":"Code Implementation"},{"location":"llvm/pass/hello-world/#register-the-pass","text":"We have finished implementing the simple pass but we havn't told LLVM pass manager about the existance of our new pass. We need to register our new pass into the pass manager. Edit llvm/lib/Passes/PassRegistry.def and add the following lines to it: 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) Note the first argument to FUNCTION_PASS is the name of our new pass. Add the following #include to llvm/lib/Passes/PassBuilder.cpp : 1 #include \"llvm/Transforms/Utils/Hello.h\" and it's done. Now time for building and running our new pass.","title":"Register the Pass"},{"location":"llvm/pass/hello-world/#build-and-run","text":"Go to the build directory and build opt , which is a dedicated tool for running passes over a piece of IR. After building opt , create a test IR file test.ll for testing: 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } Then run our new pass with opt : 1 build/bin/opt -disable-output test.ll -passes = hello The -passes=hello option make opt run HelloPass . Expected output: 1 2 foo bar Congratulations! You have finished your LLVM pass! For instructions on how to build LLVM from source, please refer to the official documentation . \u21a9 You can refer to this comment for a brief introduction to the concepts-based polymorphism used in the pass framework. \u21a9 For a detailed introduction and discussion about concepts-based polymorphism, please refer to GuillaumeDua. Concept-based polymorphism in modern C++ . \u21a9","title":"Build and Run"},{"location":"llvm/pass/hello-world.zh/","text":"\u7f16\u5199\u4e00\u4e2a Hello World Pass \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5e26\u9886\u60a8\u7f16\u5199\u5e76\u8fd0\u884c\u4e00\u4e2a\u975e\u5e38\u7b80\u5355\u7684 pass\uff0c\u8fd9\u4e2a pass \u53ef\u4ee5\u8f93\u51fa\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6240\u6709\u51fd\u6570\u7684\u540d\u79f0\u3002 \u8bbe\u7f6e\u6784\u5efa\u73af\u5883 \u5047\u8bbe\u60a8\u5df2\u7ecf\u514b\u9686\u4e86 LLVM \u4ed3\u5e93 \u5e76\u5728 build \u76ee\u5f55\u4e0b\u8bbe\u7f6e\u597d\u4e86\u6784\u5efa\u6811 1 \uff0c\u5e76\u4e14\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u662f LLVM \u4ed3\u5e93\u7684\u6839\u76ee\u5f55\u3002\u672c\u8282\u4e2d\u6211\u4eec\u5c06\u5728\u6811\u5185\u6784\u5efa\u65b0\u7684 pass\uff0c\u8fd9\u610f\u5473\u7740\u65b0\u7684 pass \u7684\u6240\u6709\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM \u4ed3\u5e93\u7684\u6e90\u4ee3\u7801\u76ee\u5f55\u4e0b\u3002 \u5728 llvm/include/llvm/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.h \u7684\u6587\u4ef6\uff1a 1 touch llvm/include/llvm/Transforms/Utils/Hello.h \u5728 llvm/lib/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.cpp \u7684\u6587\u4ef6\uff1a 1 touch llvm/lib/Transforms/Utils/Hello.cpp \u4fee\u6539 llvm/lib/Transforms/Utils/CMakeLists.txt \u5e76\u5c06 Hello.cpp \u52a0\u5165\u5230\u5bf9 add_llvm_component_library \u7684\u8c03\u7528\u4e2d\uff1a 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) \u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u5c06 Hello.cpp \u6dfb\u52a0\u5230 LLVM \u7684\u6784\u5efa\u8fc7\u7a0b\u4e2d\u3002 \u4ee3\u7801\u5b9e\u73b0 \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.h \u4e2d\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.cpp \u4e2d: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm \u662f\u7684\uff01\u8fd9\u5c31\u662f\uff08\u51e0\u4e4e\uff09\u5168\u90e8\u4e3a\u4e86\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 pass \u60a8\u9700\u8981\u7f16\u5199\u7684\u4ee3\u7801\u3002\u8ba9\u6211\u4eec\u5c06\u8fd9\u6bb5\u4ee3\u7801\u8fdb\u4e00\u6b65\u5206\u89e3\u5e76\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002 \u4e3a\u4e86\u4f7f\u7528 C++ \u521b\u5efa\u4e00\u4e2a pass\uff0c\u60a8\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u5b9e\u73b0\u4e86 pass \u6240\u9700\u8981\u7684\u8f6f\u4ef6\u63a5\u53e3\u7684\u7c7b\u3002\u4f20\u7edf\u7684\u505a\u6cd5\u662f\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u6765\u4e00\u4e2a\u7c7b\u5e76\u91cd\u5199\u67d0\u4e9b\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u63a5\u53e3\uff0c\u4f46\u65b0\u7684 pass \u7ba1\u7406\u5668\u5e76\u6ca1\u6709\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u800c\u662f\u91c7\u7528\u4e86\u4e00\u79cd\u88ab\u79f0\u4e3a \u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001 \uff08Concept-Based Polymorphism\uff09 2 3 \u7684\u65b9\u6cd5\u3002 \u53ea\u8981\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u540d\u4e3a run \u7684\u65b9\u6cd5\u4f7f\u4e4b\u53ef\u4ee5\u5728\u4e00\u6bb5 IR \u4e0a\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7c7b\u5c31\u8868\u793a\u4e00\u4e2a pass\u3002 \u4e0d\u9700\u8981\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u5b50\u7c7b\u6765\u8868\u793a\u4e00\u4e2a pass\u3002\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u7684 HelloPass \u7c7b\u7ee7\u627f\u81ea PassInfoMixin \u7c7b\uff0c\u8fd9\u4e2a\u57fa\u7c7b\u5411 HelloPass \u63d0\u4f9b\u7684\u63a5\u53e3\u4e2d\u53c8\u989d\u5916\u6dfb\u52a0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u4ee3\u7801\u3002\u4f46\u771f\u6b63\u91cd\u8981\u7684\u90e8\u5206\u662f run \u51fd\u6570\uff0c\u6b63\u662f run \u51fd\u6570\u7684\u5b58\u5728\u4f7f\u5f97 HelloPass \u8868\u793a\u4e00\u4e2a pass\u3002 run \u51fd\u6570\u63a5\u6536\u4e24\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570 F \u662f\u4e00\u4e2a IR \u51fd\u6570\uff0c\u65b0\u7684 pass \u5c06\u5728\u8fd9\u4e2a\u51fd\u6570\u4e0a\u8fd0\u884c\u3002\u6ce8\u610f F \u662f\u901a\u8fc7\u4e00\u4e2a\u975e\u5e38\u91cf\u5f15\u7528\u4f20\u9012\u8fdb\u6765\u7684\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u51fd\u6570\uff08\u4e5f\u5c31\u662f\u5bf9\u8fd9\u4e2a\u51fd\u6570\u4e2d\u5305\u542b\u7684 IR \u8fdb\u884c\u4fee\u6539\u548c\u53d8\u6362\uff09\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570 AM \u662f\u4e00\u4e2a pass \u7ba1\u7406\u5668\u7684\u5b9e\u4f8b\uff1b\u901a\u8fc7\u8fd9\u4e2a\u5b9e\u4f8b\uff0c\u65b0\u7684 pass \u53ef\u4ee5\u8bbf\u95ee\u5404\u79cd\u5206\u6790 pass \u5e76\u83b7\u5f97\u51fd\u6570\u7ea7\u522b\u7684\u5206\u6790\u4fe1\u606f\u3002 \u7531\u4e8e run \u51fd\u6570\u5c06 Function \u4f5c\u4e3a\u53c2\u6570\uff0c\u56e0\u6b64 HelloPass \u662f\u4e00\u4e2a \u51fd\u6570 pass \u3002Pass \u7ba1\u7406\u5668\u4f1a\u5b89\u6392\u51fd\u6570 pass \u4f9d\u6b21\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6bcf\u4e2a\u51fd\u6570\u4e0a\u6267\u884c\u3002\u5f53 HelloPass \u5728\u67d0\u4e2a IR \u51fd\u6570\u4e0a\u6267\u884c\u65f6\uff0c\u5b83\u4f1a\u5c06\u51fd\u6570\u7684\u540d\u79f0\u5199\u5165\u6807\u51c6\u9519\u8bef\u6d41\u7136\u540e\u9000\u51fa\u3002 run \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a PreservedAnalyses \u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u5305\u542b\u4e00\u4e9b\u4fe1\u606f\u7528\u4e8e\u6307\u793a\u5f53\u5f53\u524d\u7684 pass \u8fd0\u884c\u5b8c\u6bd5\u540e\uff0c\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\u54ea\u4e9b\u662f\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528\u7684\uff0c\u54ea\u4e9b\u662f\u4e0d\u80fd\u7ee7\u7eed\u4f7f\u7528\u7684\u3002 HelloPass \u7684 run \u51fd\u6570\u8fd4\u56de PreservedAnalyses::all() \u6765\u6307\u793a\u6240\u6709\u7684\u5206\u6790\u4fe1\u606f\u90fd\u7ee7\u7eed\u53ef\u7528\uff08\u8fd9\u662f\u56e0\u4e3a HelloPass \u5e76\u6ca1\u6709\u5bf9 IR \u8fdb\u884c\u4fee\u6539\uff0c\u4e5f\u5c31\u4e0d\u4f1a\u7834\u574f\u4efb\u4f55\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\uff09\u3002 \u6ce8\u518c Pass \u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u5bf9\u8fd9\u4e2a\u7b80\u5355\u7684 pass \u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u544a\u8bc9 pass \u7ba1\u7406\u5668\u65b0\u7684 pass \u7684\u5b58\u5728\u3002\u6211\u4eec\u9700\u8981\u5411 pass \u7ba1\u7406\u5668 \u6ce8\u518c \u65b0\u7684 pass\u3002 \u7f16\u8f91 llvm/lib/Passes/PassRegistry.def \u5e76\u5411\u5176\u4e2d\u6dfb\u52a0\u5982\u4e0b\u5185\u5bb9\uff1a 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) \u6ce8\u610f FUNCTION_PASS \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u65b0\u7684 pass \u7684\u540d\u79f0\u3002 \u5411 llvm/lib/Passes/PassBuilder.cpp \u4e2d\u6dfb\u52a0\u5982\u4e0b\u7684 #include \uff1a 1 #include \"llvm/Transforms/Utils/Hello.h\" \u6ce8\u518c\u5de5\u4f5c\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c06\u6784\u5efa\u5e76\u8fd0\u884c\u65b0\u7684 pass\u3002 \u6784\u5efa\u5e76\u8fd0\u884c \u8fdb\u5165\u6784\u5efa\u76ee\u5f55\u5e76\u6784\u5efa opt \u3002 opt \u662f\u4e00\u4e2a\u4e13\u95e8\u7528\u4e8e\u5728\u4e00\u6bb5 IR \u4e0a\u8fd0\u884c\u4e00\u4e2a\u6216\u4e00\u7cfb\u5217 pass \u7684\u5de5\u5177\u3002\u5f53 opt \u6784\u5efa\u5b8c\u6bd5\u540e\uff0c\u521b\u5efa\u4e00\u4e2a test.ll \u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\uff1a 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } \u7136\u540e\u4f7f\u7528 opt \u5de5\u5177\u8fd0\u884c\u65b0\u7684 pass\uff1a 1 build/bin/opt -disable-output test.ll -passes = hello -passes=hello \u7f16\u8bd1\u9009\u9879\u547d\u4ee4 opt \u8fd0\u884c HelloPass \u3002 opt \u5e94\u8be5\u8f93\u51fa\u5982\u4e0b\u5185\u5bb9\uff1a 1 2 foo bar \u606d\u559c\uff01\u60a8\u5b8c\u6210\u4e86\u60a8\u7684 LLVM pass\uff01 \u8bf7\u53c2\u9605 LLVM \u5b98\u65b9\u6587\u6863 \u4e86\u89e3\u5982\u4f55\u4ece\u6e90\u7801\u6784\u5efa LLVM\u3002 \u21a9 \u8fd9\u4e2a\u6ce8\u91ca \u7b80\u8981\u4ecb\u7ecd\u4e86 pass \u6846\u67b6\u4e2d\u6240\u4f7f\u7528\u7684\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u673a\u5236\u3002 \u21a9 \u5bf9\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u7684\u8be6\u7ec6\u4ecb\u7ecd\u548c\u8ba8\u8bba\u6587\u6863\u89c1 GuillaumeDua. Concept-based polymorphism in modern C++ \u3002 \u21a9","title":"llvm-pass-hello-world"},{"location":"llvm/pass/hello-world.zh/#\u7f16\u5199\u4e00\u4e2a-hello-world-pass","text":"\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4f1a\u5e26\u9886\u60a8\u7f16\u5199\u5e76\u8fd0\u884c\u4e00\u4e2a\u975e\u5e38\u7b80\u5355\u7684 pass\uff0c\u8fd9\u4e2a pass \u53ef\u4ee5\u8f93\u51fa\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6240\u6709\u51fd\u6570\u7684\u540d\u79f0\u3002","title":"\u7f16\u5199\u4e00\u4e2a Hello World Pass"},{"location":"llvm/pass/hello-world.zh/#\u8bbe\u7f6e\u6784\u5efa\u73af\u5883","text":"\u5047\u8bbe\u60a8\u5df2\u7ecf\u514b\u9686\u4e86 LLVM \u4ed3\u5e93 \u5e76\u5728 build \u76ee\u5f55\u4e0b\u8bbe\u7f6e\u597d\u4e86\u6784\u5efa\u6811 1 \uff0c\u5e76\u4e14\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u662f LLVM \u4ed3\u5e93\u7684\u6839\u76ee\u5f55\u3002\u672c\u8282\u4e2d\u6211\u4eec\u5c06\u5728\u6811\u5185\u6784\u5efa\u65b0\u7684 pass\uff0c\u8fd9\u610f\u5473\u7740\u65b0\u7684 pass \u7684\u6240\u6709\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM \u4ed3\u5e93\u7684\u6e90\u4ee3\u7801\u76ee\u5f55\u4e0b\u3002 \u5728 llvm/include/llvm/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.h \u7684\u6587\u4ef6\uff1a 1 touch llvm/include/llvm/Transforms/Utils/Hello.h \u5728 llvm/lib/Transforms/Utils/ \u4e0b\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a Hello.cpp \u7684\u6587\u4ef6\uff1a 1 touch llvm/lib/Transforms/Utils/Hello.cpp \u4fee\u6539 llvm/lib/Transforms/Utils/CMakeLists.txt \u5e76\u5c06 Hello.cpp \u52a0\u5165\u5230\u5bf9 add_llvm_component_library \u7684\u8c03\u7528\u4e2d\uff1a 1 2 3 4 5 add_llvm_component_library ( LLVMTransformUtils # Other files ... Hello.cpp # Other files and configurations ... ) \u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u5c06 Hello.cpp \u6dfb\u52a0\u5230 LLVM \u7684\u6784\u5efa\u8fc7\u7a0b\u4e2d\u3002","title":"\u8bbe\u7f6e\u6784\u5efa\u73af\u5883"},{"location":"llvm/pass/hello-world.zh/#\u4ee3\u7801\u5b9e\u73b0","text":"\u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.h \u4e2d\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #ifndef LLVM_TRANSFORMS_HELLO_H #define LLVM_TRANSFORMS_HELLO_H #include \"llvm/IR/PassManager.h\" namespace llvm { class HelloPass : public PassInfoMixin < HelloPass > { public : PreservedAnalyses run ( Function & F , FunctionAnalysisManager & AM ); }; } // namespace llvm #endif \u5c06\u5982\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 Hello.cpp \u4e2d: 1 2 3 4 5 6 7 8 9 10 #include \"llvm/Transforms/Utils/Hello.h\" namespace llvm { PreservedAnalyses HelloPass::run ( Function & F , FunctionAnalysisManager & AM ) { errs () << F . getName () << \" \\n \" ; return PreservedAnalyses :: all (); } } // namespace llvm \u662f\u7684\uff01\u8fd9\u5c31\u662f\uff08\u51e0\u4e4e\uff09\u5168\u90e8\u4e3a\u4e86\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 pass \u60a8\u9700\u8981\u7f16\u5199\u7684\u4ee3\u7801\u3002\u8ba9\u6211\u4eec\u5c06\u8fd9\u6bb5\u4ee3\u7801\u8fdb\u4e00\u6b65\u5206\u89e3\u5e76\u770b\u770b\u5b83\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002 \u4e3a\u4e86\u4f7f\u7528 C++ \u521b\u5efa\u4e00\u4e2a pass\uff0c\u60a8\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u5b9e\u73b0\u4e86 pass \u6240\u9700\u8981\u7684\u8f6f\u4ef6\u63a5\u53e3\u7684\u7c7b\u3002\u4f20\u7edf\u7684\u505a\u6cd5\u662f\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u6765\u4e00\u4e2a\u7c7b\u5e76\u91cd\u5199\u67d0\u4e9b\u865a\u51fd\u6570\u4ee5\u5b9e\u73b0\u63a5\u53e3\uff0c\u4f46\u65b0\u7684 pass \u7ba1\u7406\u5668\u5e76\u6ca1\u6709\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u800c\u662f\u91c7\u7528\u4e86\u4e00\u79cd\u88ab\u79f0\u4e3a \u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001 \uff08Concept-Based Polymorphism\uff09 2 3 \u7684\u65b9\u6cd5\u3002 \u53ea\u8981\u8fd9\u4e2a\u7c7b\u5305\u542b\u4e00\u4e2a\u540d\u4e3a run \u7684\u65b9\u6cd5\u4f7f\u4e4b\u53ef\u4ee5\u5728\u4e00\u6bb5 IR \u4e0a\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7c7b\u5c31\u8868\u793a\u4e00\u4e2a pass\u3002 \u4e0d\u9700\u8981\u4ece\u67d0\u4e2a\u57fa\u7c7b\u6d3e\u751f\u51fa\u5b50\u7c7b\u6765\u8868\u793a\u4e00\u4e2a pass\u3002\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u7684 HelloPass \u7c7b\u7ee7\u627f\u81ea PassInfoMixin \u7c7b\uff0c\u8fd9\u4e2a\u57fa\u7c7b\u5411 HelloPass \u63d0\u4f9b\u7684\u63a5\u53e3\u4e2d\u53c8\u989d\u5916\u6dfb\u52a0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u4ee3\u7801\u3002\u4f46\u771f\u6b63\u91cd\u8981\u7684\u90e8\u5206\u662f run \u51fd\u6570\uff0c\u6b63\u662f run \u51fd\u6570\u7684\u5b58\u5728\u4f7f\u5f97 HelloPass \u8868\u793a\u4e00\u4e2a pass\u3002 run \u51fd\u6570\u63a5\u6536\u4e24\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570 F \u662f\u4e00\u4e2a IR \u51fd\u6570\uff0c\u65b0\u7684 pass \u5c06\u5728\u8fd9\u4e2a\u51fd\u6570\u4e0a\u8fd0\u884c\u3002\u6ce8\u610f F \u662f\u901a\u8fc7\u4e00\u4e2a\u975e\u5e38\u91cf\u5f15\u7528\u4f20\u9012\u8fdb\u6765\u7684\uff0c\u8fd9\u8bf4\u660e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u51fd\u6570\uff08\u4e5f\u5c31\u662f\u5bf9\u8fd9\u4e2a\u51fd\u6570\u4e2d\u5305\u542b\u7684 IR \u8fdb\u884c\u4fee\u6539\u548c\u53d8\u6362\uff09\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570 AM \u662f\u4e00\u4e2a pass \u7ba1\u7406\u5668\u7684\u5b9e\u4f8b\uff1b\u901a\u8fc7\u8fd9\u4e2a\u5b9e\u4f8b\uff0c\u65b0\u7684 pass \u53ef\u4ee5\u8bbf\u95ee\u5404\u79cd\u5206\u6790 pass \u5e76\u83b7\u5f97\u51fd\u6570\u7ea7\u522b\u7684\u5206\u6790\u4fe1\u606f\u3002 \u7531\u4e8e run \u51fd\u6570\u5c06 Function \u4f5c\u4e3a\u53c2\u6570\uff0c\u56e0\u6b64 HelloPass \u662f\u4e00\u4e2a \u51fd\u6570 pass \u3002Pass \u7ba1\u7406\u5668\u4f1a\u5b89\u6392\u51fd\u6570 pass \u4f9d\u6b21\u5728\u8f93\u5165\u7684 IR \u6a21\u5757\u4e2d\u5305\u542b\u7684\u6bcf\u4e2a\u51fd\u6570\u4e0a\u6267\u884c\u3002\u5f53 HelloPass \u5728\u67d0\u4e2a IR \u51fd\u6570\u4e0a\u6267\u884c\u65f6\uff0c\u5b83\u4f1a\u5c06\u51fd\u6570\u7684\u540d\u79f0\u5199\u5165\u6807\u51c6\u9519\u8bef\u6d41\u7136\u540e\u9000\u51fa\u3002 run \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a PreservedAnalyses \u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u5305\u542b\u4e00\u4e9b\u4fe1\u606f\u7528\u4e8e\u6307\u793a\u5f53\u5f53\u524d\u7684 pass \u8fd0\u884c\u5b8c\u6bd5\u540e\uff0c\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\u54ea\u4e9b\u662f\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528\u7684\uff0c\u54ea\u4e9b\u662f\u4e0d\u80fd\u7ee7\u7eed\u4f7f\u7528\u7684\u3002 HelloPass \u7684 run \u51fd\u6570\u8fd4\u56de PreservedAnalyses::all() \u6765\u6307\u793a\u6240\u6709\u7684\u5206\u6790\u4fe1\u606f\u90fd\u7ee7\u7eed\u53ef\u7528\uff08\u8fd9\u662f\u56e0\u4e3a HelloPass \u5e76\u6ca1\u6709\u5bf9 IR \u8fdb\u884c\u4fee\u6539\uff0c\u4e5f\u5c31\u4e0d\u4f1a\u7834\u574f\u4efb\u4f55\u5df2\u6709\u7684\u5206\u6790\u4fe1\u606f\uff09\u3002","title":"\u4ee3\u7801\u5b9e\u73b0"},{"location":"llvm/pass/hello-world.zh/#\u6ce8\u518c-pass","text":"\u6211\u4eec\u5df2\u7ecf\u5b8c\u6210\u4e86\u5bf9\u8fd9\u4e2a\u7b80\u5355\u7684 pass \u7684\u5b9e\u73b0\uff0c\u4f46\u662f\u6211\u4eec\u8fd8\u6ca1\u6709\u544a\u8bc9 pass \u7ba1\u7406\u5668\u65b0\u7684 pass \u7684\u5b58\u5728\u3002\u6211\u4eec\u9700\u8981\u5411 pass \u7ba1\u7406\u5668 \u6ce8\u518c \u65b0\u7684 pass\u3002 \u7f16\u8f91 llvm/lib/Passes/PassRegistry.def \u5e76\u5411\u5176\u4e2d\u6dfb\u52a0\u5982\u4e0b\u5185\u5bb9\uff1a 1 FUNCTION_PASS ( \"hello\" , HelloPass ()) \u6ce8\u610f FUNCTION_PASS \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u65b0\u7684 pass \u7684\u540d\u79f0\u3002 \u5411 llvm/lib/Passes/PassBuilder.cpp \u4e2d\u6dfb\u52a0\u5982\u4e0b\u7684 #include \uff1a 1 #include \"llvm/Transforms/Utils/Hello.h\" \u6ce8\u518c\u5de5\u4f5c\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c06\u6784\u5efa\u5e76\u8fd0\u884c\u65b0\u7684 pass\u3002","title":"\u6ce8\u518c Pass"},{"location":"llvm/pass/hello-world.zh/#\u6784\u5efa\u5e76\u8fd0\u884c","text":"\u8fdb\u5165\u6784\u5efa\u76ee\u5f55\u5e76\u6784\u5efa opt \u3002 opt \u662f\u4e00\u4e2a\u4e13\u95e8\u7528\u4e8e\u5728\u4e00\u6bb5 IR \u4e0a\u8fd0\u884c\u4e00\u4e2a\u6216\u4e00\u7cfb\u5217 pass \u7684\u5de5\u5177\u3002\u5f53 opt \u6784\u5efa\u5b8c\u6bd5\u540e\uff0c\u521b\u5efa\u4e00\u4e2a test.ll \u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\uff1a 1 2 3 4 5 6 7 8 define i32 @foo () { %a = add i32 2 , 3 ret i32 %a } define void @bar () { ret void } \u7136\u540e\u4f7f\u7528 opt \u5de5\u5177\u8fd0\u884c\u65b0\u7684 pass\uff1a 1 build/bin/opt -disable-output test.ll -passes = hello -passes=hello \u7f16\u8bd1\u9009\u9879\u547d\u4ee4 opt \u8fd0\u884c HelloPass \u3002 opt \u5e94\u8be5\u8f93\u51fa\u5982\u4e0b\u5185\u5bb9\uff1a 1 2 foo bar \u606d\u559c\uff01\u60a8\u5b8c\u6210\u4e86\u60a8\u7684 LLVM pass\uff01 \u8bf7\u53c2\u9605 LLVM \u5b98\u65b9\u6587\u6863 \u4e86\u89e3\u5982\u4f55\u4ece\u6e90\u7801\u6784\u5efa LLVM\u3002 \u21a9 \u8fd9\u4e2a\u6ce8\u91ca \u7b80\u8981\u4ecb\u7ecd\u4e86 pass \u6846\u67b6\u4e2d\u6240\u4f7f\u7528\u7684\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u673a\u5236\u3002 \u21a9 \u5bf9\u57fa\u4e8e\u6982\u5ff5\u7684\u591a\u6001\u7684\u8be6\u7ec6\u4ecb\u7ecd\u548c\u8ba8\u8bba\u6587\u6863\u89c1 GuillaumeDua. Concept-based polymorphism in modern C++ \u3002 \u21a9","title":"\u6784\u5efa\u5e76\u8fd0\u884c"},{"location":"llvm/pass/index.zh/","text":"Pass LLVM Pass \u6846\u67b6\u662f LLVM \u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u7f16\u8bd1\u5668\u7684\u5927\u91cf\u6838\u5fc3\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM pass \u4e2d\u3002LLVM pass \u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u53d8\u6362\u548c\u4f18\u5316\uff0c\u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u5206\u6790\u5e76\u8f93\u51fa\u53d8\u6362\u548c\u4f18\u5316\u6240\u5fc5\u987b\u7684\u5206\u6790\u4fe1\u606f\uff1b\u9664\u6b64\u4e4b\u5916\uff0cLLVM pass \u4e5f\u662f\u4e00\u79cd\u5bf9\u7f16\u8bd1\u5668\u4ee3\u7801\u8fdb\u884c\u7ec4\u7ec7\u7684\u5de5\u5177\u3002 \u4e00\u4e2a LLVM pass \u53ef\u4ee5\u88ab\u89c6\u4e3a\u4e00\u4e2a\u4ee5 LLVM IR \u4f5c\u4e3a\u8f93\u5165\u3001\u5e76\u4ea7\u751f\u67d0\u79cd\u4f9d\u8d56\u4e8e\u5177\u4f53 pass \u7684\u8f93\u51fa\u7684\u9ed1\u76d2\u3002\u6709\u4e24\u79cd\u4e0d\u540c\u7684 pass\uff1a \u53d8\u6362 pass \uff08Transformation Pass\uff09 \u4ee5\u53ca \u5206\u6790 pass \uff08Analysis Pass\uff09\u3002\u4e00\u4e2a\u53d8\u6362 pass \u901a\u5e38\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR \u5e76\u5c06\u8f6c\u6362\u540e\u7684 IR \u4f5c\u4e3a\u8f93\u51fa\u3002\u53e6\u5916\uff0c\u5c06\u8f93\u5165\u7684 LLVM IR \u4e0b\u964d\u5230 SelectionDAG \u4ee5\u53ca\u673a\u5668 IR \u7684 pass \u4e5f\u662f\u53d8\u6362 pass\u3002\u4e00\u4e2a\u5206\u6790 pass \u4e0d\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR\uff0c\u4f46\u5b83\u4f1a\u5bf9\u8f93\u5165\u7684 IR \u8fdb\u884c\u5206\u6790\u5e76\u4ea7\u751f\u63cf\u8ff0 IR \u7684\u67d0\u79cd\u5c5e\u6027\u7684\u4fe1\u606f\u3002\u53d8\u6362 pass \u901a\u5e38\u7528\u4e8e\u5b9e\u73b0\u7f16\u8bd1\u4f18\u5316\u3001\u7a0b\u5e8f\u53d8\u6362\u3001\u7a0b\u5e8f\u63d2\u6869\u7b49\u4efb\u52a1\u3002\u5206\u6790 pass \u901a\u5e38\u7528\u4e8e\u4e3a\u53d8\u6362 pass \u63d0\u4f9b\u5fc5\u8981\u7684\u4fe1\u606f\u3002 \u771f\u5b9e\u4e16\u754c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u4f1a\u4f9d\u8d56\u4e8e\u4e0a\u767e\u4e2a\u5728 IR \u4e0a\u4f9d\u6b21\u6267\u884c\u7684 pass \u6765\u5b8c\u6210\u7a0b\u5e8f\u4f18\u5316\u4ee5\u53ca\u4ee3\u7801\u751f\u6210\u5de5\u4f5c\u3002\u8fd9\u4e00\u4e2a\u7531\u591a\u4e2a pass \u7ec4\u6210\u7684\u3001\u6bcf\u4e2a pass \u4f9d\u6b21\u6267\u884c\u7684 pass \u5e8f\u5217\u4e00\u822c\u4e5f\u88ab\u79f0\u4e3a \u7ba1\u7ebf\uff08The Pipeline\uff09 \u3002\u9700\u8981\u6ce8\u610f\uff0c\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u901a\u5e38\u4f1a\u5f71\u54cd\u5230\u7ba1\u7ebf\u7684\u914d\u7f6e\uff0c\u4e5f\u5c31\u662f\u7ba1\u7ebf\u4e2d\u4f7f\u7528\u7684 pass \u96c6\u5408\u4ee5\u53ca pass \u6267\u884c\u7684\u5148\u540e\u987a\u5e8f\u3002 Pass \u53ef\u4ee5\u6709 \u4f9d\u8d56 \u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u53d8\u6362 pass \u5fc5\u987b\u5728\u5b83\u6240\u6709\u4f9d\u8d56\u7684\u5206\u6790 pass \u5b8c\u6210\u4e4b\u540e\u624d\u80fd\u6b63\u5e38\u8fd0\u884c\u3002\u53e6\u5916\uff0c\u67d0\u4e9b\u53d8\u6362 pass \u4f1a\u7834\u574f\u67d0\u4e9b\u5df2\u7ecf\u5f97\u5230\u5e76\u7f13\u5b58\u4e0b\u6765\u7684\u4ee3\u7801\u5206\u6790\u7ed3\u679c\u3002LLVM \u4f7f\u7528 pass \u7ba1\u7406\u5668 \uff08Pass Manager\uff09\u5bf9\u53ef\u7528\u7684 pass \u8fdb\u884c\u7ba1\u7406\u5e76\u5c06 pass \u7ba1\u7ebf\u8c03\u5ea6\u5230\u8f93\u5165\u7684 IR \u4e0a\u6267\u884c\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u76ee\u524d LLVM \u6709\u4e24\u7ec4\u4e0d\u540c\u7684 pass manager\uff1a\u65b0 pass \u7ba1\u7406\u5668\uff08New Pass Manager\uff09\u4ee5\u53ca\u65e7 pass manager\uff08Legacy Pass Manager\uff09\u3002\u672c wiki \u4e3b\u8981\u4ecb\u7ecd\u65b0 pass \u7ba1\u7406\u5668\uff1bLLVM \u793e\u533a\u4e5f\u6b63\u5728\u5c06\u4ee3\u7801\u8fc1\u79fb\u5230\u65b0 pass \u7ba1\u7406\u5668\u5e76\u5f03\u7528\u65e7 pass \u7ba1\u7406\u5668\u3002","title":"\u6982\u8ff0"},{"location":"llvm/pass/index.zh/#pass","text":"LLVM Pass \u6846\u67b6\u662f LLVM \u7684\u4e00\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\uff0c\u7f16\u8bd1\u5668\u7684\u5927\u91cf\u6838\u5fc3\u4ee3\u7801\u90fd\u5305\u542b\u5728 LLVM pass \u4e2d\u3002LLVM pass \u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u53d8\u6362\u548c\u4f18\u5316\uff0c\u53ef\u4ee5\u5bf9\u7a0b\u5e8f\u8fdb\u884c\u5206\u6790\u5e76\u8f93\u51fa\u53d8\u6362\u548c\u4f18\u5316\u6240\u5fc5\u987b\u7684\u5206\u6790\u4fe1\u606f\uff1b\u9664\u6b64\u4e4b\u5916\uff0cLLVM pass \u4e5f\u662f\u4e00\u79cd\u5bf9\u7f16\u8bd1\u5668\u4ee3\u7801\u8fdb\u884c\u7ec4\u7ec7\u7684\u5de5\u5177\u3002 \u4e00\u4e2a LLVM pass \u53ef\u4ee5\u88ab\u89c6\u4e3a\u4e00\u4e2a\u4ee5 LLVM IR \u4f5c\u4e3a\u8f93\u5165\u3001\u5e76\u4ea7\u751f\u67d0\u79cd\u4f9d\u8d56\u4e8e\u5177\u4f53 pass \u7684\u8f93\u51fa\u7684\u9ed1\u76d2\u3002\u6709\u4e24\u79cd\u4e0d\u540c\u7684 pass\uff1a \u53d8\u6362 pass \uff08Transformation Pass\uff09 \u4ee5\u53ca \u5206\u6790 pass \uff08Analysis Pass\uff09\u3002\u4e00\u4e2a\u53d8\u6362 pass \u901a\u5e38\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR \u5e76\u5c06\u8f6c\u6362\u540e\u7684 IR \u4f5c\u4e3a\u8f93\u51fa\u3002\u53e6\u5916\uff0c\u5c06\u8f93\u5165\u7684 LLVM IR \u4e0b\u964d\u5230 SelectionDAG \u4ee5\u53ca\u673a\u5668 IR \u7684 pass \u4e5f\u662f\u53d8\u6362 pass\u3002\u4e00\u4e2a\u5206\u6790 pass \u4e0d\u4f1a\u4fee\u6539\u8f93\u5165\u7684 IR\uff0c\u4f46\u5b83\u4f1a\u5bf9\u8f93\u5165\u7684 IR \u8fdb\u884c\u5206\u6790\u5e76\u4ea7\u751f\u63cf\u8ff0 IR \u7684\u67d0\u79cd\u5c5e\u6027\u7684\u4fe1\u606f\u3002\u53d8\u6362 pass \u901a\u5e38\u7528\u4e8e\u5b9e\u73b0\u7f16\u8bd1\u4f18\u5316\u3001\u7a0b\u5e8f\u53d8\u6362\u3001\u7a0b\u5e8f\u63d2\u6869\u7b49\u4efb\u52a1\u3002\u5206\u6790 pass \u901a\u5e38\u7528\u4e8e\u4e3a\u53d8\u6362 pass \u63d0\u4f9b\u5fc5\u8981\u7684\u4fe1\u606f\u3002 \u771f\u5b9e\u4e16\u754c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u4f1a\u4f9d\u8d56\u4e8e\u4e0a\u767e\u4e2a\u5728 IR \u4e0a\u4f9d\u6b21\u6267\u884c\u7684 pass \u6765\u5b8c\u6210\u7a0b\u5e8f\u4f18\u5316\u4ee5\u53ca\u4ee3\u7801\u751f\u6210\u5de5\u4f5c\u3002\u8fd9\u4e00\u4e2a\u7531\u591a\u4e2a pass \u7ec4\u6210\u7684\u3001\u6bcf\u4e2a pass \u4f9d\u6b21\u6267\u884c\u7684 pass \u5e8f\u5217\u4e00\u822c\u4e5f\u88ab\u79f0\u4e3a \u7ba1\u7ebf\uff08The Pipeline\uff09 \u3002\u9700\u8981\u6ce8\u610f\uff0c\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u901a\u5e38\u4f1a\u5f71\u54cd\u5230\u7ba1\u7ebf\u7684\u914d\u7f6e\uff0c\u4e5f\u5c31\u662f\u7ba1\u7ebf\u4e2d\u4f7f\u7528\u7684 pass \u96c6\u5408\u4ee5\u53ca pass \u6267\u884c\u7684\u5148\u540e\u987a\u5e8f\u3002 Pass \u53ef\u4ee5\u6709 \u4f9d\u8d56 \u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u53d8\u6362 pass \u5fc5\u987b\u5728\u5b83\u6240\u6709\u4f9d\u8d56\u7684\u5206\u6790 pass \u5b8c\u6210\u4e4b\u540e\u624d\u80fd\u6b63\u5e38\u8fd0\u884c\u3002\u53e6\u5916\uff0c\u67d0\u4e9b\u53d8\u6362 pass \u4f1a\u7834\u574f\u67d0\u4e9b\u5df2\u7ecf\u5f97\u5230\u5e76\u7f13\u5b58\u4e0b\u6765\u7684\u4ee3\u7801\u5206\u6790\u7ed3\u679c\u3002LLVM \u4f7f\u7528 pass \u7ba1\u7406\u5668 \uff08Pass Manager\uff09\u5bf9\u53ef\u7528\u7684 pass \u8fdb\u884c\u7ba1\u7406\u5e76\u5c06 pass \u7ba1\u7ebf\u8c03\u5ea6\u5230\u8f93\u5165\u7684 IR \u4e0a\u6267\u884c\u3002\u4f46\u662f\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u76ee\u524d LLVM \u6709\u4e24\u7ec4\u4e0d\u540c\u7684 pass manager\uff1a\u65b0 pass \u7ba1\u7406\u5668\uff08New Pass Manager\uff09\u4ee5\u53ca\u65e7 pass manager\uff08Legacy Pass Manager\uff09\u3002\u672c wiki \u4e3b\u8981\u4ecb\u7ecd\u65b0 pass \u7ba1\u7406\u5668\uff1bLLVM \u793e\u533a\u4e5f\u6b63\u5728\u5c06\u4ee3\u7801\u8fc1\u79fb\u5230\u65b0 pass \u7ba1\u7406\u5668\u5e76\u5f03\u7528\u65e7 pass \u7ba1\u7406\u5668\u3002","title":"Pass"},{"location":"mlir/mlir/","text":"Multi-Level Intermediate Representation The MLIR project is developing rapidly, and the situation may change at any time, please pay attention to the writing time of the page when reading . The MLIR project is a novel approach to building reusable and extensible compiler infrastructure. MLIR aims to address software fragmentation, improve compilation for heterogeneous hardware, significantly reduce the cost of building domain-specific compilers, and aid in connecting existing compilers together. In simple terms, MLIR is a general framework for writing various types of analyzes and transforms in compilers and the intermediate representations they require. It provides a series of facilities for compiler developers to define new IRs and use existing IRs conveniently and quickly. Developers can easily mix various IRs, freely converting between them, and make different levels of analysis to finally generate the object code. The MLIR project also contains some pre-written \"IRs\" ready for immediate use. You can start to understand these existing \"IRs\" and learn how to build your own \"IR\" from the basic concepts and building blocks of MLIR: dialect . Introduction to this section of the wiki This section of the wiki aims to: Aids in the development of MLIR itself Assist in the development of new dialects based on MLIR Assist in the use of MLIR's existing dialects and passes Related Links Official Documentation CodeGen Dialect Overview A post introducing the descent path of each dialect in MLIR. Although it is a bit old and some dialects have been dismantled, the classification is worth pondering. A picture is worth a thousand words , and you should definitely read the pictures even if you are too busy reading the words. The author classifies MLIR with two dimensions: data and algorithm. From Tensor -> Buffer, the data gradually changes from abstract tensor to memory. From Structure -> Payload, algorithms from high-level, structured descriptions to low-level, imperative codes The author also shared the concerns of each dialect","title":"mlir-overview"},{"location":"mlir/mlir/#multi-level-intermediate-representation","text":"The MLIR project is developing rapidly, and the situation may change at any time, please pay attention to the writing time of the page when reading . The MLIR project is a novel approach to building reusable and extensible compiler infrastructure. MLIR aims to address software fragmentation, improve compilation for heterogeneous hardware, significantly reduce the cost of building domain-specific compilers, and aid in connecting existing compilers together. In simple terms, MLIR is a general framework for writing various types of analyzes and transforms in compilers and the intermediate representations they require. It provides a series of facilities for compiler developers to define new IRs and use existing IRs conveniently and quickly. Developers can easily mix various IRs, freely converting between them, and make different levels of analysis to finally generate the object code. The MLIR project also contains some pre-written \"IRs\" ready for immediate use. You can start to understand these existing \"IRs\" and learn how to build your own \"IR\" from the basic concepts and building blocks of MLIR: dialect .","title":"Multi-Level Intermediate Representation"},{"location":"mlir/mlir/#introduction-to-this-section-of-the-wiki","text":"This section of the wiki aims to: Aids in the development of MLIR itself Assist in the development of new dialects based on MLIR Assist in the use of MLIR's existing dialects and passes","title":"Introduction to this section of the wiki"},{"location":"mlir/mlir/#related-links","text":"Official Documentation CodeGen Dialect Overview A post introducing the descent path of each dialect in MLIR. Although it is a bit old and some dialects have been dismantled, the classification is worth pondering. A picture is worth a thousand words , and you should definitely read the pictures even if you are too busy reading the words. The author classifies MLIR with two dimensions: data and algorithm. From Tensor -> Buffer, the data gradually changes from abstract tensor to memory. From Structure -> Payload, algorithms from high-level, structured descriptions to low-level, imperative codes The author also shared the concerns of each dialect","title":"Related Links"},{"location":"mlir/mlir.zh/","text":"Multi-Level Intermediate Representation MLIR \u9879\u76ee\u6b63\u5728\u6781\u901f\u53d1\u5c55\u4e2d\uff0c\u60c5\u51b5\u968f\u65f6\u6709\u53ef\u80fd\u53d1\u751f\u53d8\u5316\uff0c\u8bf7\u5728\u9605\u8bfb\u65f6\u5173\u6ce8\u9875\u9762\u7684\u4e66\u5199\u65f6\u95f4 . MLIR \u9879\u76ee\u662f\u4e00\u6b21\u5168\u65b0\u7684\uff0c\u6784\u5efa\u53ef\u91cd\u7528\u3001\u53ef\u6269\u5c55\u7684\u7f16\u8bd1\u5668\u57fa\u7840\u8bbe\u65bd\u7684\u5c1d\u8bd5\u3002\u5b83\u65e8\u5728\u89e3\u51b3\u8f6f\u4ef6\u788e\u7247\u5316\u95ee\u9898\uff0c\u6539\u8fdb\u5f02\u6784\u786c\u4ef6\u4e0a\u7684\u7f16\u8bd1\uff0c\u51cf\u5c11\u9886\u57df\u7279\u5b9a\u7f16\u8bd1\u5668\u7684\u5f00\u53d1\u4ee3\u4ef7\uff0c\u4ee5\u53ca\u8fde\u63a5\u73b0\u6709\u7684\u7f16\u8bd1\u5668\u8bbe\u65bd\u3002 \u7b80\u5355\u6765\u8bf4\uff0cMLIR \u662f\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002\u5176\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u8bbe\u65bd\u4ee5\u4f9b\u7f16\u8bd1\u5668\u5f00\u53d1\u8005\u65b9\u4fbf\u5feb\u901f\u5730\u5b9a\u4e49\u65b0\u7684 IR \u4e0e\u4f7f\u7528\u73b0\u6709\u7684\u5404\u7c7b IR. \u5f00\u53d1\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u6df7\u7528\u5404\u7c7b IR, \u5728\u5b83\u4eec\u4e4b\u4e2d\u4e0e\u4e4b\u95f4\u81ea\u7531\u8f6c\u6362\uff0c\u8fdb\u884c\u4e0d\u540c\u5c42\u6b21\u7684\u5206\u6790\uff0c\u6700\u7ec8\u751f\u6210\u76ee\u6807\u4ee3\u7801\u3002 MLIR \u9879\u76ee\u4e2d\u8fd8\u5305\u542b\u4e86\u4e00\u4e9b\u5df2\u7ecf\u7f16\u5199\u597d\u7684 \"IR\", \u53ef\u4f9b\u76f4\u63a5\u4f7f\u7528\u3002\u53ef\u4ee5\u4ece MLIR \u7684\u57fa\u672c\u6982\u5ff5\u4e0e\u7ec4\u6210\u6a21\u5757\uff1a \u65b9\u8a00 \u5f00\u59cb\u4e86\u89e3\u8fd9\u4e9b\u73b0\u6709\u7684 \"IR\" \u4e0e\u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684 \"IR\". \u672c Wiki \u7b80\u4ecb \u672c Wiki \u65e8\u5728\uff1a \u8f85\u52a9 MLIR \u672c\u8eab\u7684\u5f00\u53d1 \u8f85\u52a9\u57fa\u4e8e MLIR \u7684\u65b0\u65b9\u8a00\u7684\u5f00\u53d1 \u8f85\u52a9\u5bf9 MLIR \u81ea\u5e26\u65b9\u8a00\u4e0e pass \u7684\u4f7f\u7528 \u76f8\u5173\u94fe\u63a5 \u5b98\u65b9\u6587\u6863 CodeGen Dialect Overview \u4e00\u7bc7\u4ecb\u7ecd MLIR \u4e2d\u5404\u4e2a\u65b9\u8a00\u4e0b\u964d\u8def\u5f84\u7684\u5e16\u5b50\uff0c\u867d\u7136\u8001\u4e86\u4e00\u70b9\uff0c\u6709\u4e9b\u65b9\u8a00\u5df2\u7ecf\u88ab\u62c6\u4e86\uff0c\u4f46\u662f\u5176\u4e2d\u7684\u5206\u7c7b\u503c\u5f97\u6df1\u601d\u3002\u5176\u4e2d\u7684\u56fe\u7247\u66f4\u662f \u4e00\u56fe\u80dc\u5343\u8a00\uff0c\u4e0d\u770b\u5b57\u4e5f\u5f97\u770b\u56fe\u3002 \u4f5c\u8005\u5c06 MLIR \u6309\u7167\u6570\u636e - \u7b97\u6cd5\u4e24\u4e2a\u7ef4\u5ea6\u5206\u7c7b\u3002\u6570\u636e\u4ece Tensor -> Buffer, \u9010\u6e10\u4ece\u62bd\u8c61\u7684\u5f20\u91cf\u5177\u4f53\u5230\u5185\u5b58\u3002\u7b97\u6cd5\u4ece Structure -> Payload, \u4e5f\u5c31\u662f\u4ece\u9ad8\u5c42\u7684\uff0c\u7ed3\u6784\u5316\u7684\u63cf\u8ff0\u5230\u5e95\u5c42\u7684\uff0c\u547d\u4ee4\u5f0f\u7684\u4e1c\u897f \u4f5c\u8005\u8fd8\u5206\u4eab\u4e86\u5404\u4e2a\u65b9\u8a00\u7684\u5173\u6ce8\u70b9 \u5982\u4f55\u8bc4\u4ef7 MLIR \u9879\u76ee\u4e2d Linalg Dialect \u7684\u8bbe\u8ba1\u601d\u60f3\uff1f - mackler \u7684\u56de\u7b54 - \u77e5\u4e4e \u5bf9 MLIR \u7684\u6bd4\u8f83 \"\u5c16\u9510\" \u7684\u610f\u89c1 \u5176\u5bf9\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u5206\u7c7b\u4ee4\u4eba\u773c\u524d\u4e00\u4eae\uff1aauto-tiling/auto-tensorize/auto-schedule \u4e00\u4e9b\u5173\u6ce8 MLIR \u7684\u4e2d\u6587\u4f7f\u7528\u8005\uff0c\u53ef\u4ee5\u8ddf\u7740 timeline \u770b\u770b hunterzju : \u4e3b\u8981\u5173\u6ce8 CIRCT \u9879\u76ee, \u5199\u4e86\u4e00\u4e9b MLIR Toy Tutorial \u7684\u7b14\u8bb0\u548c\u6587\u6863\u7684\u7ffb\u8bd1 mackler : \u4e3b\u8981\u504f\u5411 MLIR \u5728 AI \u9886\u57df\u7684\u5de5\u4f5c\uff0c\u867d\u7136 ta \u53ef\u80fd\u66f4\u591a\u7684\u662f\u5173\u6ce8\u5e7f\u4e49\u7684\u8ba1\u7b97\u673a\u4f53\u7cfb\u548c\u4f18\u5316 \u6cd5\u65af\u7279\u8c6a\u65af : Buddy-mlir \u9879\u76ee\u7684 \"\u4e3b\u6301\u4eba\", \u57fa\u672c\u4e0a\u4e3b\u9875\u90fd\u662f\u5173\u4e8e MLIR \u7684\u4fe1\u606f MLIR \u4e2d\u56fd\u793e\u533a : \u987e\u540d\u601d\u4e49","title":"mlir-overview"},{"location":"mlir/mlir.zh/#multi-level-intermediate-representation","text":"MLIR \u9879\u76ee\u6b63\u5728\u6781\u901f\u53d1\u5c55\u4e2d\uff0c\u60c5\u51b5\u968f\u65f6\u6709\u53ef\u80fd\u53d1\u751f\u53d8\u5316\uff0c\u8bf7\u5728\u9605\u8bfb\u65f6\u5173\u6ce8\u9875\u9762\u7684\u4e66\u5199\u65f6\u95f4 . MLIR \u9879\u76ee\u662f\u4e00\u6b21\u5168\u65b0\u7684\uff0c\u6784\u5efa\u53ef\u91cd\u7528\u3001\u53ef\u6269\u5c55\u7684\u7f16\u8bd1\u5668\u57fa\u7840\u8bbe\u65bd\u7684\u5c1d\u8bd5\u3002\u5b83\u65e8\u5728\u89e3\u51b3\u8f6f\u4ef6\u788e\u7247\u5316\u95ee\u9898\uff0c\u6539\u8fdb\u5f02\u6784\u786c\u4ef6\u4e0a\u7684\u7f16\u8bd1\uff0c\u51cf\u5c11\u9886\u57df\u7279\u5b9a\u7f16\u8bd1\u5668\u7684\u5f00\u53d1\u4ee3\u4ef7\uff0c\u4ee5\u53ca\u8fde\u63a5\u73b0\u6709\u7684\u7f16\u8bd1\u5668\u8bbe\u65bd\u3002 \u7b80\u5355\u6765\u8bf4\uff0cMLIR \u662f\u7528\u4e8e\u7f16\u5199\u7f16\u8bd1\u5668\u4e2d\u5404\u7c7b\u5206\u6790\u4e0e\u53d8\u6362\u53ca\u5176\u6240\u9700\u7684\u4e2d\u95f4\u8868\u793a\u7684\u901a\u7528\u6846\u67b6\u3002\u5176\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u8bbe\u65bd\u4ee5\u4f9b\u7f16\u8bd1\u5668\u5f00\u53d1\u8005\u65b9\u4fbf\u5feb\u901f\u5730\u5b9a\u4e49\u65b0\u7684 IR \u4e0e\u4f7f\u7528\u73b0\u6709\u7684\u5404\u7c7b IR. \u5f00\u53d1\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u6df7\u7528\u5404\u7c7b IR, \u5728\u5b83\u4eec\u4e4b\u4e2d\u4e0e\u4e4b\u95f4\u81ea\u7531\u8f6c\u6362\uff0c\u8fdb\u884c\u4e0d\u540c\u5c42\u6b21\u7684\u5206\u6790\uff0c\u6700\u7ec8\u751f\u6210\u76ee\u6807\u4ee3\u7801\u3002 MLIR \u9879\u76ee\u4e2d\u8fd8\u5305\u542b\u4e86\u4e00\u4e9b\u5df2\u7ecf\u7f16\u5199\u597d\u7684 \"IR\", \u53ef\u4f9b\u76f4\u63a5\u4f7f\u7528\u3002\u53ef\u4ee5\u4ece MLIR \u7684\u57fa\u672c\u6982\u5ff5\u4e0e\u7ec4\u6210\u6a21\u5757\uff1a \u65b9\u8a00 \u5f00\u59cb\u4e86\u89e3\u8fd9\u4e9b\u73b0\u6709\u7684 \"IR\" \u4e0e\u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684 \"IR\".","title":"Multi-Level Intermediate Representation"},{"location":"mlir/mlir.zh/#\u672c-wiki-\u7b80\u4ecb","text":"\u672c Wiki \u65e8\u5728\uff1a \u8f85\u52a9 MLIR \u672c\u8eab\u7684\u5f00\u53d1 \u8f85\u52a9\u57fa\u4e8e MLIR \u7684\u65b0\u65b9\u8a00\u7684\u5f00\u53d1 \u8f85\u52a9\u5bf9 MLIR \u81ea\u5e26\u65b9\u8a00\u4e0e pass \u7684\u4f7f\u7528","title":"\u672c Wiki \u7b80\u4ecb"},{"location":"mlir/mlir.zh/#\u76f8\u5173\u94fe\u63a5","text":"\u5b98\u65b9\u6587\u6863 CodeGen Dialect Overview \u4e00\u7bc7\u4ecb\u7ecd MLIR \u4e2d\u5404\u4e2a\u65b9\u8a00\u4e0b\u964d\u8def\u5f84\u7684\u5e16\u5b50\uff0c\u867d\u7136\u8001\u4e86\u4e00\u70b9\uff0c\u6709\u4e9b\u65b9\u8a00\u5df2\u7ecf\u88ab\u62c6\u4e86\uff0c\u4f46\u662f\u5176\u4e2d\u7684\u5206\u7c7b\u503c\u5f97\u6df1\u601d\u3002\u5176\u4e2d\u7684\u56fe\u7247\u66f4\u662f \u4e00\u56fe\u80dc\u5343\u8a00\uff0c\u4e0d\u770b\u5b57\u4e5f\u5f97\u770b\u56fe\u3002 \u4f5c\u8005\u5c06 MLIR \u6309\u7167\u6570\u636e - \u7b97\u6cd5\u4e24\u4e2a\u7ef4\u5ea6\u5206\u7c7b\u3002\u6570\u636e\u4ece Tensor -> Buffer, \u9010\u6e10\u4ece\u62bd\u8c61\u7684\u5f20\u91cf\u5177\u4f53\u5230\u5185\u5b58\u3002\u7b97\u6cd5\u4ece Structure -> Payload, \u4e5f\u5c31\u662f\u4ece\u9ad8\u5c42\u7684\uff0c\u7ed3\u6784\u5316\u7684\u63cf\u8ff0\u5230\u5e95\u5c42\u7684\uff0c\u547d\u4ee4\u5f0f\u7684\u4e1c\u897f \u4f5c\u8005\u8fd8\u5206\u4eab\u4e86\u5404\u4e2a\u65b9\u8a00\u7684\u5173\u6ce8\u70b9 \u5982\u4f55\u8bc4\u4ef7 MLIR \u9879\u76ee\u4e2d Linalg Dialect \u7684\u8bbe\u8ba1\u601d\u60f3\uff1f - mackler \u7684\u56de\u7b54 - \u77e5\u4e4e \u5bf9 MLIR \u7684\u6bd4\u8f83 \"\u5c16\u9510\" \u7684\u610f\u89c1 \u5176\u5bf9\u7f16\u8bd1\u5668\u4f18\u5316\u7684\u5206\u7c7b\u4ee4\u4eba\u773c\u524d\u4e00\u4eae\uff1aauto-tiling/auto-tensorize/auto-schedule \u4e00\u4e9b\u5173\u6ce8 MLIR \u7684\u4e2d\u6587\u4f7f\u7528\u8005\uff0c\u53ef\u4ee5\u8ddf\u7740 timeline \u770b\u770b hunterzju : \u4e3b\u8981\u5173\u6ce8 CIRCT \u9879\u76ee, \u5199\u4e86\u4e00\u4e9b MLIR Toy Tutorial \u7684\u7b14\u8bb0\u548c\u6587\u6863\u7684\u7ffb\u8bd1 mackler : \u4e3b\u8981\u504f\u5411 MLIR \u5728 AI \u9886\u57df\u7684\u5de5\u4f5c\uff0c\u867d\u7136 ta \u53ef\u80fd\u66f4\u591a\u7684\u662f\u5173\u6ce8\u5e7f\u4e49\u7684\u8ba1\u7b97\u673a\u4f53\u7cfb\u548c\u4f18\u5316 \u6cd5\u65af\u7279\u8c6a\u65af : Buddy-mlir \u9879\u76ee\u7684 \"\u4e3b\u6301\u4eba\", \u57fa\u672c\u4e0a\u4e3b\u9875\u90fd\u662f\u5173\u4e8e MLIR \u7684\u4fe1\u606f MLIR \u4e2d\u56fd\u793e\u533a : \u987e\u540d\u601d\u4e49","title":"\u76f8\u5173\u94fe\u63a5"},{"location":"mlir/basic/dialect/","text":"Dialect Dialects are a crucial part of MLIR. It can be said that MLIR without various dialects is like a language without a standard library, and will not have any practical use. If the MLIR framework itself is compared to the foundation, then the various dialects built on top of MLIR are buildings with different styles. Data and information flow within and between buildings, forming a city with ducks in a row. As far as learning is concerned, the learning of dialects can be divided into two parts: Learn how to construct your dialect Learn the meaning of various operations in the built-in dialect The former is like learning to build a building, and the latter is like visiting a \"model house\". Basic Concepts A dialect can completely define anything that belongs to it, like new operations, properties, and types. New operations in the dialect can define their exclusive syntax format and output format. It is very reasonable and normal to see operations with unique text forms in the operations of different dialects. Things from different dialects can coexist harmoniously in the same module/function. At the same time, dialect writers can provide passes that convert operations in other dialects to their dialects, and can also write passes that convert operations in their dialects to other dialects. These conversions can be completed, converting all operations in A dialect to B; or step by step, only converting certain operations in A to B, and converting the rest to C. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Define a function using the func operator in the func dialect // Using a custom syntax, the textual form of the operation looks similar to a function definition in a normal language func. func @main() { // use constant operations in the arith dialect // using the basic syntax %lb = arith.constant 0 : index %ub = arith. constant 5 : index %step = arith. constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // use the for operator in the scf dialect // It has custom syntax and can be written to look like \"trailing closures\" in other languages // takes a \"function\" as its own parameter %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf. yield %1 : f32 } // use the print operation in the vector dialect vector.print %sum : f32 return } After this example is written, various conversion passes can be used to gradually or directly convert operations in various dialects into operations in LLVM dialects, and then translate them into LLVM IR to obtain executable files. It can be seen that each dialect is very free. So to read MLIR code text, it is not enough to only be familiar with the MLIR core framework. You must refer to the documentation of the dialect you want to use, and be familiar with the meaning and syntax of each operation in them, to read efficiently. All dialects are equal, but some dialects are more equal, and they are the dialects that are shipped in the MLIR project repository. These dialects are widely used. Before learning other dialects, it is recommended to read the documentation of [some of the most commonly used built-in dialects] (#Common Dialects). Build a New Dialect This part can refer to the official Toy Tutorial . Learn the Built-in Dialect Currently, the MLIR official repository contains some built-in dialects and conversions between them. These dialects can be regarded as MLIR's \"standard library\". Depending on the degree of versatility and focus, they can be classified as follows: Due to the rapid development of MLIR, the list of dialects below will not be guaranteed to be complete. For a complete list, please refer to the official documentation . Common Dialects The following are very generic dialects. Any other built-in dialects will more or less use the operations in the above dialects. Learning them is an important part of understanding existing dialects: builtin : built-in dialect, contains some facilities that may be used in all dialects, and should theoretically be kept very small. It also contains type definitions for the basic types of each built-in dialect func : function dialect, used to express function definition/function call arith : arithmetic dialect, including various basic arithmetic operations affine : affine transformation dialect, which is a high-level description of index space/address space mapping memref : memory area dialect, which is a high-level abstraction of memory and various operations on it There are also generic dialects, but may relatively be used less than the dialects above: cf : Express unstructured control flow, such as goto and the like scf : express structured control flow, such as for/while/if math : common numerical operation functions complex : commonly used complex numerical operation functions index : platform-independent operations on indexed types, perhaps comparable to \"high-level pointer arithmetic\" LLVM Dialects Then there is a very specific dialect: llvm , the LLVM dialect. It's a dialect that maintains a one-to-one mapping with concepts in LLVM IR. It acts as the \"lowest level\" in most dialect-lowering paths. Other dialects gradually lower to the LLVM dialect, and then translated into LLVM IR, and then have various optimizations of LLVM and the ability to translate to all backends of LLVM. If you don't understand an operation in a dialect, while it provides a lowering pass, you can read the lowering pass to understand what it means. The whole process is similar to learning C from a C compiler. In this process, the LLVM dialect acts like an assembly language. Domain-Specific Dialects There are some domain-specific dialects, most of which are designed to effectively express information highly related to a certain domain at a very high level of abstraction. So an understanding of specific domains will play a great role in understanding the following dialects. They are: vector : dialect for auto-vectorization, designed to express information about various SIMD operations in a platform-independent manner linalg : high-level abstraction related to deep learning model representation spirv : support for SPIR-V , a dialect for expressing graphics concepts such as shaders omp : support for OpenMP for expressing automatic multithreading related concepts gpu : GPU dialect designed to express platform-independently operations on the GPU async : dialect for expressing asynchronous operations pdl , pdl_interp : MLIR dialect for MLIR transformation, making it possible to use MLIR pass to analyze MLIR pass Platform-dependent Dialects Among the above dialects, there are also some dialects for platform-specific optimization. They are designed to describe the characteristics of a certain CPU or instruction set in detail and guide the optimization. Their names are relatively intuitive: GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"mlir-dialect"},{"location":"mlir/basic/dialect/#dialect","text":"Dialects are a crucial part of MLIR. It can be said that MLIR without various dialects is like a language without a standard library, and will not have any practical use. If the MLIR framework itself is compared to the foundation, then the various dialects built on top of MLIR are buildings with different styles. Data and information flow within and between buildings, forming a city with ducks in a row. As far as learning is concerned, the learning of dialects can be divided into two parts: Learn how to construct your dialect Learn the meaning of various operations in the built-in dialect The former is like learning to build a building, and the latter is like visiting a \"model house\".","title":"Dialect"},{"location":"mlir/basic/dialect/#basic-concepts","text":"A dialect can completely define anything that belongs to it, like new operations, properties, and types. New operations in the dialect can define their exclusive syntax format and output format. It is very reasonable and normal to see operations with unique text forms in the operations of different dialects. Things from different dialects can coexist harmoniously in the same module/function. At the same time, dialect writers can provide passes that convert operations in other dialects to their dialects, and can also write passes that convert operations in their dialects to other dialects. These conversions can be completed, converting all operations in A dialect to B; or step by step, only converting certain operations in A to B, and converting the rest to C. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Define a function using the func operator in the func dialect // Using a custom syntax, the textual form of the operation looks similar to a function definition in a normal language func. func @main() { // use constant operations in the arith dialect // using the basic syntax %lb = arith.constant 0 : index %ub = arith. constant 5 : index %step = arith. constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // use the for operator in the scf dialect // It has custom syntax and can be written to look like \"trailing closures\" in other languages // takes a \"function\" as its own parameter %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf. yield %1 : f32 } // use the print operation in the vector dialect vector.print %sum : f32 return } After this example is written, various conversion passes can be used to gradually or directly convert operations in various dialects into operations in LLVM dialects, and then translate them into LLVM IR to obtain executable files. It can be seen that each dialect is very free. So to read MLIR code text, it is not enough to only be familiar with the MLIR core framework. You must refer to the documentation of the dialect you want to use, and be familiar with the meaning and syntax of each operation in them, to read efficiently. All dialects are equal, but some dialects are more equal, and they are the dialects that are shipped in the MLIR project repository. These dialects are widely used. Before learning other dialects, it is recommended to read the documentation of [some of the most commonly used built-in dialects] (#Common Dialects).","title":"Basic Concepts"},{"location":"mlir/basic/dialect/#build-a-new-dialect","text":"This part can refer to the official Toy Tutorial .","title":"Build a New Dialect"},{"location":"mlir/basic/dialect/#learn-the-built-in-dialect","text":"Currently, the MLIR official repository contains some built-in dialects and conversions between them. These dialects can be regarded as MLIR's \"standard library\". Depending on the degree of versatility and focus, they can be classified as follows: Due to the rapid development of MLIR, the list of dialects below will not be guaranteed to be complete. For a complete list, please refer to the official documentation .","title":"Learn the Built-in Dialect"},{"location":"mlir/basic/dialect/#common-dialects","text":"The following are very generic dialects. Any other built-in dialects will more or less use the operations in the above dialects. Learning them is an important part of understanding existing dialects: builtin : built-in dialect, contains some facilities that may be used in all dialects, and should theoretically be kept very small. It also contains type definitions for the basic types of each built-in dialect func : function dialect, used to express function definition/function call arith : arithmetic dialect, including various basic arithmetic operations affine : affine transformation dialect, which is a high-level description of index space/address space mapping memref : memory area dialect, which is a high-level abstraction of memory and various operations on it There are also generic dialects, but may relatively be used less than the dialects above: cf : Express unstructured control flow, such as goto and the like scf : express structured control flow, such as for/while/if math : common numerical operation functions complex : commonly used complex numerical operation functions index : platform-independent operations on indexed types, perhaps comparable to \"high-level pointer arithmetic\"","title":"Common Dialects"},{"location":"mlir/basic/dialect/#llvm-dialects","text":"Then there is a very specific dialect: llvm , the LLVM dialect. It's a dialect that maintains a one-to-one mapping with concepts in LLVM IR. It acts as the \"lowest level\" in most dialect-lowering paths. Other dialects gradually lower to the LLVM dialect, and then translated into LLVM IR, and then have various optimizations of LLVM and the ability to translate to all backends of LLVM. If you don't understand an operation in a dialect, while it provides a lowering pass, you can read the lowering pass to understand what it means. The whole process is similar to learning C from a C compiler. In this process, the LLVM dialect acts like an assembly language.","title":"LLVM Dialects"},{"location":"mlir/basic/dialect/#domain-specific-dialects","text":"There are some domain-specific dialects, most of which are designed to effectively express information highly related to a certain domain at a very high level of abstraction. So an understanding of specific domains will play a great role in understanding the following dialects. They are: vector : dialect for auto-vectorization, designed to express information about various SIMD operations in a platform-independent manner linalg : high-level abstraction related to deep learning model representation spirv : support for SPIR-V , a dialect for expressing graphics concepts such as shaders omp : support for OpenMP for expressing automatic multithreading related concepts gpu : GPU dialect designed to express platform-independently operations on the GPU async : dialect for expressing asynchronous operations pdl , pdl_interp : MLIR dialect for MLIR transformation, making it possible to use MLIR pass to analyze MLIR pass","title":"Domain-Specific Dialects"},{"location":"mlir/basic/dialect/#platform-dependent-dialects","text":"Among the above dialects, there are also some dialects for platform-specific optimization. They are designed to describe the characteristics of a certain CPU or instruction set in detail and guide the optimization. Their names are relatively intuitive: GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"Platform-dependent Dialects"},{"location":"mlir/basic/dialect.zh/","text":"\u65b9\u8a00 \u65b9\u8a00\u662f MLIR \u4e2d\u81f3\u5173\u91cd\u8981\u7684\u90e8\u5206\u3002\u53ef\u4ee5\u8bf4\uff0c\u6ca1\u6709\u5404\u7c7b\u65b9\u8a00\u7684 MLIR \u5c31\u5982\u540c\u4e00\u95e8\u6ca1\u6709\u6807\u51c6\u5e93\u7684\u8bed\u8a00\u4e00\u6837\uff0c\u5c06\u4e0d\u4f1a\u6709\u4efb\u4f55\u73b0\u5b9e\u7684\u7528\u5904\u3002\u5982\u679c\u5c06 MLIR \u6846\u67b6\u672c\u8eab\u6bd4\u4f5c\u5730\u57fa\u7684\u8bdd\uff0c\u90a3\u4e48\u5728 MLIR \u4e4b\u4e0a\u6784\u5efa\u800c\u51fa\u7684\u5404\u79cd\u65b9\u8a00\u4fbf\u662f\u4e00\u5ea7\u5ea7\u98ce\u683c\u5404\u5f02\u7684\u5927\u697c\u3002\u6570\u636e\u4e0e\u4fe1\u606f\u5728\u5927\u697c\u4e4b\u5185\u4e0e\u4e4b\u95f4\u4e92\u76f8\u6d41\u8f6c\uff0c\u6784\u6210\u4e00\u5ea7\u6709\u673a\u7684\u57ce\u5e02\u3002 \u5c31\u5b66\u4e60\u800c\u8a00\uff0c\u5bf9\u65b9\u8a00\u7684\u5b66\u4e60\u53c8\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff1a \u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684\u65b9\u8a00 \u5b66\u4e60\u81ea\u5e26\u7684\u65b9\u8a00\u4e2d\u5404\u7c7b\u64cd\u4f5c\u7684\u610f\u4e49 \u524d\u8005\u5c31\u597d\u6bd4\u5b66\u4e60\u9020\u697c\uff0c\u540e\u8005\u5c31\u7c7b\u4f3c\u4e8e\u53c2\u89c2 \"\u6837\u677f\u623f\". \u57fa\u672c\u6982\u5ff5 \u4e00\u4e2a\u65b9\u8a00\u57fa\u672c\u4e0a\u53ef\u4ee5\u5b8c\u5168\u5b9a\u4e49\u5c5e\u4e8e\u5b83\u7684\u4efb\u4f55\u4e1c\u897f\uff0c\u6bd4\u5982\u65b0\u7684\u64cd\u4f5c/\u5c5e\u6027/\u7c7b\u578b\u3002\u65b9\u8a00\u91cc\u7684\u65b0\u64cd\u4f5c\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u4e13\u5c5e\u7684\u8bed\u6cd5\u683c\u5f0f\u548c\u8f93\u51fa\u683c\u5f0f\u3002\u5728\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u64cd\u4f5c\u4e2d\u89c1\u5230\u6587\u672c\u5f62\u5f0f\u6bd4\u8f83\u72ec\u7279\u7684\u64cd\u4f5c\u662f\u975e\u5e38\u5408\u7406\u4e14\u6b63\u5e38\u7684\u3002 \u6765\u81ea\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u4e8b\u7269\u53ef\u4ee5\u548c\u8c10\u5171\u5b58\u4e8e\u540c\u4e00\u4e2a\u6a21\u5757/\u51fd\u6570\u3002\u540c\u65f6\u65b9\u8a00\u7f16\u5199\u8005\u53ef\u4ee5\u63d0\u4f9b\u5c06\u522b\u7684\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u81ea\u5df1\u65b9\u8a00\u4e2d\u7684 pass, \u4e5f\u53ef\u4ee5\u7f16\u5199\u5c06\u81ea\u5df1\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u5176\u5b83\u65b9\u8a00\u53bb\u7684 pass \u3002\u8fd9\u4e9b\u8f6c\u6362\u53ef\u4ee5\u662f\u5b8c\u5168\u7684\uff0c\u5c06 A \u65b9\u8a00\u6240\u6709\u64cd\u4f5c\u90fd\u8f6c\u5230 B \u53bb\uff0c\u53e6\u5916\u4e5f\u53ef\u4ee5\u9010\u6b65\u8f6c\u6362\uff0c\u4f8b\u5982\u53ea\u628a A \u4e2d\u90e8\u5206\u64cd\u4f5c\u8f6c\u5230 B, \u7136\u540e\u5269\u4e0b\u7684\u8f6c\u5230 C. \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u4f7f\u7528 func \u65b9\u8a00\u4e2d\u7684 func \u64cd\u4f5c\u6765\u5b9a\u4e49\u51fd\u6570 // \u4f7f\u7528\u4e86\u81ea\u5b9a\u4e49\u8bed\u6cd5, \u4f7f\u5f97\u8be5\u64cd\u4f5c\u7684\u6587\u672c\u5f62\u5f0f\u770b\u8d77\u6765\u8ddf\u666e\u901a\u8bed\u8a00\u4e2d\u7684\u51fd\u6570\u5b9a\u4e49\u7c7b\u4f3c func.func @main() { // \u4f7f\u7528 arith \u65b9\u8a00\u4e2d\u7684 constant \u64cd\u4f5c // \u4f7f\u7528\u4e86\u57fa\u672c\u7684\u8bed\u6cd5 %lb = arith.constant 0 : index %ub = arith.constant 5 : index %step = arith.constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // \u4f7f\u7528 scf \u65b9\u8a00\u4e2d\u7684 for \u64cd\u4f5c // \u5b83\u6709\u81ea\u5b9a\u4e49\u7684\u8bed\u6cd5, \u53ef\u4ee5\u5199\u6210\u770b\u8d77\u6765\u50cf\u5176\u5b83\u8bed\u8a00\u4e2d\u7684 \"\u5c3e\u968f\u95ed\u5305\" \u4e00\u6837\u7684\u5199\u6cd5 // \u5c06\u4e00\u4e2a \"\u51fd\u6570\" \u4f5c\u4e3a\u81ea\u5df1\u7684\u53c2\u6570 %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf.yield %1 : f32 } // \u4f7f\u7528 vector \u65b9\u8a00\u4e2d\u7684 print \u64cd\u4f5c vector.print %sum : f32 return } \u8fd9\u4e2a\u4f8b\u5b50\u7f16\u5199\u5b8c\u540e\uff0c\u4fbf\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd\u8f6c\u6362 pass, \u6216\u9010\u6b65\u6216\u76f4\u63a5\u5730\u5c06\u5404\u79cd\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\u8f6c\u6362\u4e3a LLVM \u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u968f\u540e\u7ffb\u8bd1\u4e3a LLVM IR, \u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5404\u4e2a\u65b9\u8a00\u5185\u90e8\u662f\u975e\u5e38\u81ea\u7531\u7684\u3002\u6240\u4ee5\u8981\u9605\u8bfb MLIR \u4ee3\u7801\u6587\u672c\uff0c\u53ea\u719f\u6089 MLIR \u6838\u5fc3\u6846\u67b6\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\u3002\u5fc5\u987b\u53c2\u8003\u4f60\u6240\u8981\u4f7f\u7528\u7684\u65b9\u8a00\u7684\u6587\u6863\uff0c\u719f\u6089\u5b83\u4eec\u4e4b\u4e2d\u5404\u4e2a\u64cd\u4f5c\u7684\u610f\u4e49\u4e0e\u8bed\u6cd5\uff0c\u624d\u80fd\u9ad8\u6548\u9605\u8bfb\u3002 \u6240\u6709\u65b9\u8a00\u90fd\u662f\u5e73\u7b49\u7684\uff0c\u4f46\u6709\u4e9b\u65b9\u8a00\u66f4\u52a0\u5e73\u7b49\uff0c\u5b83\u4eec\u662f\u88ab\u81ea\u5e26\u5728 MLIR \u9879\u76ee\u4ed3\u5e93\u91cc\u7684\u65b9\u8a00\u3002\u8fd9\u4e9b\u65b9\u8a00\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u5728\u5b66\u4e60\u5176\u5b83\u65b9\u8a00\u4e4b\u524d\uff0c\u63a8\u8350\u5148\u9605\u8bfb \u6700\u4e3a\u5e38\u7528\u7684\u4e00\u4e9b\u81ea\u5e26\u65b9\u8a00 \u7684\u6587\u6863\u3002 \u6784\u5efa\u65b0\u7684\u65b9\u8a00 \u6b64\u90e8\u5206\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u7684 Toy Tutorial \u3002 \u5b66\u4e60\u81ea\u5e26\u65b9\u8a00 \u76ee\u524d MLIR \u5b98\u65b9\u4ed3\u5e93\u4e2d\u5305\u542b\u4e86\u4e00\u4e9b\u81ea\u5e26\u7684\u65b9\u8a00\u548c\u5b83\u4eec\u4e4b\u95f4\u7684\u8f6c\u6362\u3002\u8fd9\u4e9b\u65b9\u8a00\u53ef\u4ee5\u89c6\u4f5c MLIR \u7684 \"\u6807\u51c6\u5e93\". \u89c6\u6cdb\u7528\u7a0b\u5ea6\u548c\u5173\u6ce8\u70b9\u4e0d\u540c\uff0c\u53c8\u53ef\u4ee5\u5c06\u5b83\u4eec\u5206\u7c7b\u5982\u4e0b\uff1a \u7531\u4e8e MLIR \u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u4e0b\u9762\u7684\u65b9\u8a00\u5217\u8868\u5c06\u4e0d\u4f1a\u4fdd\u8bc1\u662f\u5b8c\u5168\u7684\u3002\u5b8c\u6574\u5217\u8868\u8bf7\u53c2\u8003 \u5b98\u65b9\u6587\u6863 (en) \u3002 \u901a\u7528\u65b9\u8a00 \u4e0b\u9762\u662f\u975e\u5e38\u901a\u7528\u7684\u65b9\u8a00\uff0c\u57fa\u672c\u4e0a\u4efb\u4f55\u5176\u5b83\u81ea\u5e26\u65b9\u8a00\u90fd\u4f1a\u6216\u591a\u6216\u5c11\u5730\u7528\u5230\u4e0a\u9762\u7684\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u5bf9\u5b83\u4eec\u7684\u5b66\u4e60\u662f\u770b\u61c2\u73b0\u6709\u65b9\u8a00\u7684\u91cd\u8981\u90e8\u5206\uff1a builtin : \u5185\u5efa\u65b9\u8a00, \u5305\u542b\u4e00\u4e9b\u5728\u6240\u6709\u65b9\u8a00\u4e2d\u90fd\u53ef\u80fd\u7528\u5230\u7684\u8bbe\u65bd, \u7406\u8bba\u4e0a\u5e94\u8be5\u4e00\u76f4\u4fdd\u6301\u975e\u5e38\u5c0f. \u5b83\u8fd8\u540c\u65f6\u5305\u542b\u4e86\u5404\u4e2a\u81ea\u5e26\u65b9\u8a00\u7684\u57fa\u672c\u7c7b\u578b\u7684\u7c7b\u578b\u5b9a\u4e49 func : \u51fd\u6570\u65b9\u8a00, \u7528\u4e8e\u8868\u8fbe\u51fd\u6570\u5b9a\u4e49/\u51fd\u6570\u8c03\u7528 arith : \u7b97\u672f\u65b9\u8a00, \u5305\u542b\u5404\u7c7b\u57fa\u672c\u7b97\u672f\u64cd\u4f5c affine : \u4eff\u5c04\u53d8\u6362\u65b9\u8a00, \u662f\u5bf9\u7d22\u5f15\u7a7a\u95f4/\u5730\u5740\u7a7a\u95f4\u6620\u5c04\u7684\u9ad8\u5c42\u63cf\u8ff0 memref : \u5185\u5b58\u533a\u57df\u65b9\u8a00, \u662f\u5bf9\u5185\u5b58\u7684\u9ad8\u5c42\u62bd\u8c61\u4e0e\u62bd\u8c61\u4e4b\u4e0a\u7684\u5404\u7c7b\u64cd\u4f5c \u8fd8\u6709\u4e00\u4e9b\u76f8\u5bf9\u4e0d\u90a3\u4e48\u5e38\u7528\u7684\u4f46\u662f\u4e5f\u662f\u901a\u7528\u7684\u65b9\u8a00\uff1a cf : \u8868\u8fbe\u975e\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 goto \u4e4b\u7c7b\u7684 scf : \u8868\u8fbe\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 for/while/if \u4e4b\u7c7b\u7684 math : \u5e38\u7528\u6570\u503c\u8fd0\u7b97\u51fd\u6570 complex : \u5e38\u7528\u590d\u6570\u6570\u503c\u8fd0\u7b97\u51fd\u6570 index : \u5e73\u53f0\u65e0\u5173\u7684\u5bf9\u7d22\u5f15\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u6216\u8bb8\u53ef\u4ee5\u6bd4\u4f5c \"\u9ad8\u5c42\u6307\u9488\u7b97\u672f\" LLVM \u65b9\u8a00 \u7136\u540e\u662f\u4e00\u4e2a\u975e\u5e38\u7279\u6b8a\u7684\u65b9\u8a00: llvm , LLVM \u65b9\u8a00. \u5b83\u57fa\u672c\u4e0a\u5c31\u662f\u4e00\u4e2a\u8ddf\u4fdd\u6301\u8ddf LLVM IR \u4e2d\u7684\u6982\u5ff5\u4e00\u5bf9\u4e00\u6620\u5c04\u7684\u65b9\u8a00. \u5b83\u5728\u5927\u90e8\u5206\u65b9\u8a00\u4e0b\u964d\u7684\u8fc7\u7a0b\u4e2d\u5145\u5f53 \"\u6700\u5e95\u5c42\" \u7684\u65b9\u8a00, \u5176\u5b83\u65b9\u8a00\u9010\u6b65\u4e0b\u964d\u5230 LLVM \u65b9\u8a00\u4e4b\u540e, \u518d\u5c06 LLVM \u65b9\u8a00\u7ffb\u8bd1\u4e3a LLVM IR, \u968f\u540e\u4fbf\u62e5\u6709\u4e86 LLVM \u7684\u5404\u7c7b\u4f18\u5316\u4e0e\u7ffb\u8bd1\u5230 LLVM \u6240\u6709\u540e\u7aef\u7684\u80fd\u529b\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u65b9\u8a00\u4e2d\u64cd\u4f5c\u770b\u4e0d\u61c2\uff0c\u5e76\u4e14\u5b83\u540c\u65f6\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a lowering pass \u7684\u8bdd\uff0c\u4f60\u5c31\u53ef\u4ee5\u901a\u8fc7\u9605\u8bfb lowering pass \u770b\u61c2\u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u610f\u601d\u3002\u6574\u4e2a\u8fc7\u7a0b\u7c7b\u4f3c\u4e8e\u4ece\u4e00\u4e2a C \u8bed\u8a00\u7f16\u8bd1\u5668\u4e2d\u5b66\u4e60 C \u8bed\u8a00\u4e00\u6837\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\uff0cLLVM \u65b9\u8a00\u5145\u5f53\u7c7b\u4f3c\u6c47\u7f16\u8bed\u8a00\u7684\u89d2\u8272\u3002 \u9886\u57df\u7279\u5b9a\u65b9\u8a00 \u63a5\u4e0b\u6765\u4fbf\u662f\u4e00\u4e9b\u9886\u57df\u7279\u5b9a\u65b9\u8a00\uff0c\u5b83\u4eec\u7684\u51fa\u73b0\u591a\u534a\u662f\u4e3a\u4e86\u6709\u6548\u5730\u5728\u62bd\u8c61\u7684\u9ad8\u5c42\u8868\u8fbe\u4e0e\u67d0\u4e2a\u9886\u57df\u9ad8\u5ea6\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u5bf9\u7279\u5b9a\u9886\u57df\u7684\u7406\u89e3\u4f1a\u5bf9\u7406\u89e3\u4e0b\u9762\u7684\u81ea\u5e26\u65b9\u8a00\u8d77\u5230\u6781\u5927\u7684\u5e2e\u52a9\u3002\u5b83\u4eec\u6709\uff1a vector : \u5411\u91cf\u5316\u65b9\u8a00, \u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe\u5404\u7c7b SIMD \u64cd\u4f5c\u7684\u4fe1\u606f linalg : \u4e0e\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8868\u793a\u76f8\u5173\u7684\u9ad8\u5c42\u62bd\u8c61 spirv : \u5bf9 SPIR-V \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u56fe\u5f62\u7740\u8272\u5668\u7b49\u56fe\u5f62\u5b66\u9886\u57df\u6982\u5ff5\u7684\u65b9\u8a00 omp : \u5bf9 OpenMP \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u81ea\u52a8\u591a\u7ebf\u7a0b\u76f8\u5173\u7684\u6982\u5ff5 gpu : GPU \u65b9\u8a00\uff0c\u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe GPU \u4e0a\u7684\u64cd\u4f5c\u7684\u4fe1\u606f async : \u8868\u8fbe\u5f02\u6b65\u64cd\u4f5c\u7684\u65b9\u8a00 pdl , pdl_interp : \u7528\u4e8e\u8868\u8fbe MLIR \u53d8\u6362\u7684 MLIR \u65b9\u8a00\uff0c\u65b9\u4fbf\u4f7f\u7528 MLIR pass \u6765\u5206\u6790 MLIR pass \u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00 \u81ea\u5e26\u65b9\u8a00\u4e2d\u8fd8\u6709\u5f88\u591a\u7528\u4e8e\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u7684\u65b9\u8a00\u3002\u5b83\u4eec\u65e8\u5728\u8be6\u7ec6\u63cf\u8ff0\u67d0\u4e2a CPU \u6216\u8005\u6307\u4ee4\u96c6\u7684\u7279\u6027\uff0c\u6307\u5bfc\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u3002\u5b83\u4eec\u7684\u540d\u5b57\u90fd\u6bd4\u8f83\u76f4\u89c2\uff1a GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"mlir-dialect"},{"location":"mlir/basic/dialect.zh/#\u65b9\u8a00","text":"\u65b9\u8a00\u662f MLIR \u4e2d\u81f3\u5173\u91cd\u8981\u7684\u90e8\u5206\u3002\u53ef\u4ee5\u8bf4\uff0c\u6ca1\u6709\u5404\u7c7b\u65b9\u8a00\u7684 MLIR \u5c31\u5982\u540c\u4e00\u95e8\u6ca1\u6709\u6807\u51c6\u5e93\u7684\u8bed\u8a00\u4e00\u6837\uff0c\u5c06\u4e0d\u4f1a\u6709\u4efb\u4f55\u73b0\u5b9e\u7684\u7528\u5904\u3002\u5982\u679c\u5c06 MLIR \u6846\u67b6\u672c\u8eab\u6bd4\u4f5c\u5730\u57fa\u7684\u8bdd\uff0c\u90a3\u4e48\u5728 MLIR \u4e4b\u4e0a\u6784\u5efa\u800c\u51fa\u7684\u5404\u79cd\u65b9\u8a00\u4fbf\u662f\u4e00\u5ea7\u5ea7\u98ce\u683c\u5404\u5f02\u7684\u5927\u697c\u3002\u6570\u636e\u4e0e\u4fe1\u606f\u5728\u5927\u697c\u4e4b\u5185\u4e0e\u4e4b\u95f4\u4e92\u76f8\u6d41\u8f6c\uff0c\u6784\u6210\u4e00\u5ea7\u6709\u673a\u7684\u57ce\u5e02\u3002 \u5c31\u5b66\u4e60\u800c\u8a00\uff0c\u5bf9\u65b9\u8a00\u7684\u5b66\u4e60\u53c8\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff1a \u5b66\u4e60\u5982\u4f55\u6784\u5efa\u81ea\u5df1\u7684\u65b9\u8a00 \u5b66\u4e60\u81ea\u5e26\u7684\u65b9\u8a00\u4e2d\u5404\u7c7b\u64cd\u4f5c\u7684\u610f\u4e49 \u524d\u8005\u5c31\u597d\u6bd4\u5b66\u4e60\u9020\u697c\uff0c\u540e\u8005\u5c31\u7c7b\u4f3c\u4e8e\u53c2\u89c2 \"\u6837\u677f\u623f\".","title":"\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u57fa\u672c\u6982\u5ff5","text":"\u4e00\u4e2a\u65b9\u8a00\u57fa\u672c\u4e0a\u53ef\u4ee5\u5b8c\u5168\u5b9a\u4e49\u5c5e\u4e8e\u5b83\u7684\u4efb\u4f55\u4e1c\u897f\uff0c\u6bd4\u5982\u65b0\u7684\u64cd\u4f5c/\u5c5e\u6027/\u7c7b\u578b\u3002\u65b9\u8a00\u91cc\u7684\u65b0\u64cd\u4f5c\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u4e13\u5c5e\u7684\u8bed\u6cd5\u683c\u5f0f\u548c\u8f93\u51fa\u683c\u5f0f\u3002\u5728\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u64cd\u4f5c\u4e2d\u89c1\u5230\u6587\u672c\u5f62\u5f0f\u6bd4\u8f83\u72ec\u7279\u7684\u64cd\u4f5c\u662f\u975e\u5e38\u5408\u7406\u4e14\u6b63\u5e38\u7684\u3002 \u6765\u81ea\u4e0d\u540c\u7684\u65b9\u8a00\u7684\u4e8b\u7269\u53ef\u4ee5\u548c\u8c10\u5171\u5b58\u4e8e\u540c\u4e00\u4e2a\u6a21\u5757/\u51fd\u6570\u3002\u540c\u65f6\u65b9\u8a00\u7f16\u5199\u8005\u53ef\u4ee5\u63d0\u4f9b\u5c06\u522b\u7684\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u81ea\u5df1\u65b9\u8a00\u4e2d\u7684 pass, \u4e5f\u53ef\u4ee5\u7f16\u5199\u5c06\u81ea\u5df1\u65b9\u8a00\u91cc\u7684\u64cd\u4f5c\u8f6c\u6362\u5230\u5176\u5b83\u65b9\u8a00\u53bb\u7684 pass \u3002\u8fd9\u4e9b\u8f6c\u6362\u53ef\u4ee5\u662f\u5b8c\u5168\u7684\uff0c\u5c06 A \u65b9\u8a00\u6240\u6709\u64cd\u4f5c\u90fd\u8f6c\u5230 B \u53bb\uff0c\u53e6\u5916\u4e5f\u53ef\u4ee5\u9010\u6b65\u8f6c\u6362\uff0c\u4f8b\u5982\u53ea\u628a A \u4e2d\u90e8\u5206\u64cd\u4f5c\u8f6c\u5230 B, \u7136\u540e\u5269\u4e0b\u7684\u8f6c\u5230 C. \u8003\u8651\u4e0b\u9762\u7684\u4f8b\u5b50\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u4f7f\u7528 func \u65b9\u8a00\u4e2d\u7684 func \u64cd\u4f5c\u6765\u5b9a\u4e49\u51fd\u6570 // \u4f7f\u7528\u4e86\u81ea\u5b9a\u4e49\u8bed\u6cd5, \u4f7f\u5f97\u8be5\u64cd\u4f5c\u7684\u6587\u672c\u5f62\u5f0f\u770b\u8d77\u6765\u8ddf\u666e\u901a\u8bed\u8a00\u4e2d\u7684\u51fd\u6570\u5b9a\u4e49\u7c7b\u4f3c func.func @main() { // \u4f7f\u7528 arith \u65b9\u8a00\u4e2d\u7684 constant \u64cd\u4f5c // \u4f7f\u7528\u4e86\u57fa\u672c\u7684\u8bed\u6cd5 %lb = arith.constant 0 : index %ub = arith.constant 5 : index %step = arith.constant 1 : index %sum_0 = arith.constant 0.0 : f32 %t = arith.constant 5.0 : f32 // \u4f7f\u7528 scf \u65b9\u8a00\u4e2d\u7684 for \u64cd\u4f5c // \u5b83\u6709\u81ea\u5b9a\u4e49\u7684\u8bed\u6cd5, \u53ef\u4ee5\u5199\u6210\u770b\u8d77\u6765\u50cf\u5176\u5b83\u8bed\u8a00\u4e2d\u7684 \"\u5c3e\u968f\u95ed\u5305\" \u4e00\u6837\u7684\u5199\u6cd5 // \u5c06\u4e00\u4e2a \"\u51fd\u6570\" \u4f5c\u4e3a\u81ea\u5df1\u7684\u53c2\u6570 %sum = scf.for %iv = %lb to %ub step %step iter_args(%sum_iter = %sum_0) -> (f32) { %1 = arith.addf %sum_iter , %t : f32 scf.yield %1 : f32 } // \u4f7f\u7528 vector \u65b9\u8a00\u4e2d\u7684 print \u64cd\u4f5c vector.print %sum : f32 return } \u8fd9\u4e2a\u4f8b\u5b50\u7f16\u5199\u5b8c\u540e\uff0c\u4fbf\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd\u8f6c\u6362 pass, \u6216\u9010\u6b65\u6216\u76f4\u63a5\u5730\u5c06\u5404\u79cd\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\u8f6c\u6362\u4e3a LLVM \u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u968f\u540e\u7ffb\u8bd1\u4e3a LLVM IR, \u5f97\u5230\u53ef\u6267\u884c\u6587\u4ef6\u3002\u53ef\u4ee5\u770b\u5230\uff0c\u5404\u4e2a\u65b9\u8a00\u5185\u90e8\u662f\u975e\u5e38\u81ea\u7531\u7684\u3002\u6240\u4ee5\u8981\u9605\u8bfb MLIR \u4ee3\u7801\u6587\u672c\uff0c\u53ea\u719f\u6089 MLIR \u6838\u5fc3\u6846\u67b6\u662f\u8fdc\u8fdc\u4e0d\u591f\u7684\u3002\u5fc5\u987b\u53c2\u8003\u4f60\u6240\u8981\u4f7f\u7528\u7684\u65b9\u8a00\u7684\u6587\u6863\uff0c\u719f\u6089\u5b83\u4eec\u4e4b\u4e2d\u5404\u4e2a\u64cd\u4f5c\u7684\u610f\u4e49\u4e0e\u8bed\u6cd5\uff0c\u624d\u80fd\u9ad8\u6548\u9605\u8bfb\u3002 \u6240\u6709\u65b9\u8a00\u90fd\u662f\u5e73\u7b49\u7684\uff0c\u4f46\u6709\u4e9b\u65b9\u8a00\u66f4\u52a0\u5e73\u7b49\uff0c\u5b83\u4eec\u662f\u88ab\u81ea\u5e26\u5728 MLIR \u9879\u76ee\u4ed3\u5e93\u91cc\u7684\u65b9\u8a00\u3002\u8fd9\u4e9b\u65b9\u8a00\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u5728\u5b66\u4e60\u5176\u5b83\u65b9\u8a00\u4e4b\u524d\uff0c\u63a8\u8350\u5148\u9605\u8bfb \u6700\u4e3a\u5e38\u7528\u7684\u4e00\u4e9b\u81ea\u5e26\u65b9\u8a00 \u7684\u6587\u6863\u3002","title":"\u57fa\u672c\u6982\u5ff5"},{"location":"mlir/basic/dialect.zh/#\u6784\u5efa\u65b0\u7684\u65b9\u8a00","text":"\u6b64\u90e8\u5206\u53ef\u4ee5\u53c2\u8003\u5b98\u65b9\u7684 Toy Tutorial \u3002","title":"\u6784\u5efa\u65b0\u7684\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u5b66\u4e60\u81ea\u5e26\u65b9\u8a00","text":"\u76ee\u524d MLIR \u5b98\u65b9\u4ed3\u5e93\u4e2d\u5305\u542b\u4e86\u4e00\u4e9b\u81ea\u5e26\u7684\u65b9\u8a00\u548c\u5b83\u4eec\u4e4b\u95f4\u7684\u8f6c\u6362\u3002\u8fd9\u4e9b\u65b9\u8a00\u53ef\u4ee5\u89c6\u4f5c MLIR \u7684 \"\u6807\u51c6\u5e93\". \u89c6\u6cdb\u7528\u7a0b\u5ea6\u548c\u5173\u6ce8\u70b9\u4e0d\u540c\uff0c\u53c8\u53ef\u4ee5\u5c06\u5b83\u4eec\u5206\u7c7b\u5982\u4e0b\uff1a \u7531\u4e8e MLIR \u7684\u9ad8\u901f\u53d1\u5c55\uff0c\u4e0b\u9762\u7684\u65b9\u8a00\u5217\u8868\u5c06\u4e0d\u4f1a\u4fdd\u8bc1\u662f\u5b8c\u5168\u7684\u3002\u5b8c\u6574\u5217\u8868\u8bf7\u53c2\u8003 \u5b98\u65b9\u6587\u6863 (en) \u3002","title":"\u5b66\u4e60\u81ea\u5e26\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u901a\u7528\u65b9\u8a00","text":"\u4e0b\u9762\u662f\u975e\u5e38\u901a\u7528\u7684\u65b9\u8a00\uff0c\u57fa\u672c\u4e0a\u4efb\u4f55\u5176\u5b83\u81ea\u5e26\u65b9\u8a00\u90fd\u4f1a\u6216\u591a\u6216\u5c11\u5730\u7528\u5230\u4e0a\u9762\u7684\u65b9\u8a00\u4e2d\u7684\u64cd\u4f5c\uff0c\u5bf9\u5b83\u4eec\u7684\u5b66\u4e60\u662f\u770b\u61c2\u73b0\u6709\u65b9\u8a00\u7684\u91cd\u8981\u90e8\u5206\uff1a builtin : \u5185\u5efa\u65b9\u8a00, \u5305\u542b\u4e00\u4e9b\u5728\u6240\u6709\u65b9\u8a00\u4e2d\u90fd\u53ef\u80fd\u7528\u5230\u7684\u8bbe\u65bd, \u7406\u8bba\u4e0a\u5e94\u8be5\u4e00\u76f4\u4fdd\u6301\u975e\u5e38\u5c0f. \u5b83\u8fd8\u540c\u65f6\u5305\u542b\u4e86\u5404\u4e2a\u81ea\u5e26\u65b9\u8a00\u7684\u57fa\u672c\u7c7b\u578b\u7684\u7c7b\u578b\u5b9a\u4e49 func : \u51fd\u6570\u65b9\u8a00, \u7528\u4e8e\u8868\u8fbe\u51fd\u6570\u5b9a\u4e49/\u51fd\u6570\u8c03\u7528 arith : \u7b97\u672f\u65b9\u8a00, \u5305\u542b\u5404\u7c7b\u57fa\u672c\u7b97\u672f\u64cd\u4f5c affine : \u4eff\u5c04\u53d8\u6362\u65b9\u8a00, \u662f\u5bf9\u7d22\u5f15\u7a7a\u95f4/\u5730\u5740\u7a7a\u95f4\u6620\u5c04\u7684\u9ad8\u5c42\u63cf\u8ff0 memref : \u5185\u5b58\u533a\u57df\u65b9\u8a00, \u662f\u5bf9\u5185\u5b58\u7684\u9ad8\u5c42\u62bd\u8c61\u4e0e\u62bd\u8c61\u4e4b\u4e0a\u7684\u5404\u7c7b\u64cd\u4f5c \u8fd8\u6709\u4e00\u4e9b\u76f8\u5bf9\u4e0d\u90a3\u4e48\u5e38\u7528\u7684\u4f46\u662f\u4e5f\u662f\u901a\u7528\u7684\u65b9\u8a00\uff1a cf : \u8868\u8fbe\u975e\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 goto \u4e4b\u7c7b\u7684 scf : \u8868\u8fbe\u7ed3\u6784\u5316\u63a7\u5236\u6d41, \u6bd4\u5982 for/while/if \u4e4b\u7c7b\u7684 math : \u5e38\u7528\u6570\u503c\u8fd0\u7b97\u51fd\u6570 complex : \u5e38\u7528\u590d\u6570\u6570\u503c\u8fd0\u7b97\u51fd\u6570 index : \u5e73\u53f0\u65e0\u5173\u7684\u5bf9\u7d22\u5f15\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u6216\u8bb8\u53ef\u4ee5\u6bd4\u4f5c \"\u9ad8\u5c42\u6307\u9488\u7b97\u672f\"","title":"\u901a\u7528\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#llvm-\u65b9\u8a00","text":"\u7136\u540e\u662f\u4e00\u4e2a\u975e\u5e38\u7279\u6b8a\u7684\u65b9\u8a00: llvm , LLVM \u65b9\u8a00. \u5b83\u57fa\u672c\u4e0a\u5c31\u662f\u4e00\u4e2a\u8ddf\u4fdd\u6301\u8ddf LLVM IR \u4e2d\u7684\u6982\u5ff5\u4e00\u5bf9\u4e00\u6620\u5c04\u7684\u65b9\u8a00. \u5b83\u5728\u5927\u90e8\u5206\u65b9\u8a00\u4e0b\u964d\u7684\u8fc7\u7a0b\u4e2d\u5145\u5f53 \"\u6700\u5e95\u5c42\" \u7684\u65b9\u8a00, \u5176\u5b83\u65b9\u8a00\u9010\u6b65\u4e0b\u964d\u5230 LLVM \u65b9\u8a00\u4e4b\u540e, \u518d\u5c06 LLVM \u65b9\u8a00\u7ffb\u8bd1\u4e3a LLVM IR, \u968f\u540e\u4fbf\u62e5\u6709\u4e86 LLVM \u7684\u5404\u7c7b\u4f18\u5316\u4e0e\u7ffb\u8bd1\u5230 LLVM \u6240\u6709\u540e\u7aef\u7684\u80fd\u529b\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u65b9\u8a00\u4e2d\u64cd\u4f5c\u770b\u4e0d\u61c2\uff0c\u5e76\u4e14\u5b83\u540c\u65f6\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a lowering pass \u7684\u8bdd\uff0c\u4f60\u5c31\u53ef\u4ee5\u901a\u8fc7\u9605\u8bfb lowering pass \u770b\u61c2\u5b83\u5230\u5e95\u662f\u4ec0\u4e48\u610f\u601d\u3002\u6574\u4e2a\u8fc7\u7a0b\u7c7b\u4f3c\u4e8e\u4ece\u4e00\u4e2a C \u8bed\u8a00\u7f16\u8bd1\u5668\u4e2d\u5b66\u4e60 C \u8bed\u8a00\u4e00\u6837\u3002\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\uff0cLLVM \u65b9\u8a00\u5145\u5f53\u7c7b\u4f3c\u6c47\u7f16\u8bed\u8a00\u7684\u89d2\u8272\u3002","title":"LLVM \u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u9886\u57df\u7279\u5b9a\u65b9\u8a00","text":"\u63a5\u4e0b\u6765\u4fbf\u662f\u4e00\u4e9b\u9886\u57df\u7279\u5b9a\u65b9\u8a00\uff0c\u5b83\u4eec\u7684\u51fa\u73b0\u591a\u534a\u662f\u4e3a\u4e86\u6709\u6548\u5730\u5728\u62bd\u8c61\u7684\u9ad8\u5c42\u8868\u8fbe\u4e0e\u67d0\u4e2a\u9886\u57df\u9ad8\u5ea6\u76f8\u5173\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u5bf9\u7279\u5b9a\u9886\u57df\u7684\u7406\u89e3\u4f1a\u5bf9\u7406\u89e3\u4e0b\u9762\u7684\u81ea\u5e26\u65b9\u8a00\u8d77\u5230\u6781\u5927\u7684\u5e2e\u52a9\u3002\u5b83\u4eec\u6709\uff1a vector : \u5411\u91cf\u5316\u65b9\u8a00, \u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe\u5404\u7c7b SIMD \u64cd\u4f5c\u7684\u4fe1\u606f linalg : \u4e0e\u6df1\u5ea6\u5b66\u4e60\u6a21\u578b\u8868\u793a\u76f8\u5173\u7684\u9ad8\u5c42\u62bd\u8c61 spirv : \u5bf9 SPIR-V \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u56fe\u5f62\u7740\u8272\u5668\u7b49\u56fe\u5f62\u5b66\u9886\u57df\u6982\u5ff5\u7684\u65b9\u8a00 omp : \u5bf9 OpenMP \u7684\u652f\u6301\uff0c\u7528\u4e8e\u8868\u8fbe\u81ea\u52a8\u591a\u7ebf\u7a0b\u76f8\u5173\u7684\u6982\u5ff5 gpu : GPU \u65b9\u8a00\uff0c\u65e8\u5728\u5e73\u53f0\u65e0\u5173\u5730\u8868\u8fbe GPU \u4e0a\u7684\u64cd\u4f5c\u7684\u4fe1\u606f async : \u8868\u8fbe\u5f02\u6b65\u64cd\u4f5c\u7684\u65b9\u8a00 pdl , pdl_interp : \u7528\u4e8e\u8868\u8fbe MLIR \u53d8\u6362\u7684 MLIR \u65b9\u8a00\uff0c\u65b9\u4fbf\u4f7f\u7528 MLIR pass \u6765\u5206\u6790 MLIR pass","title":"\u9886\u57df\u7279\u5b9a\u65b9\u8a00"},{"location":"mlir/basic/dialect.zh/#\u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00","text":"\u81ea\u5e26\u65b9\u8a00\u4e2d\u8fd8\u6709\u5f88\u591a\u7528\u4e8e\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u7684\u65b9\u8a00\u3002\u5b83\u4eec\u65e8\u5728\u8be6\u7ec6\u63cf\u8ff0\u67d0\u4e2a CPU \u6216\u8005\u6307\u4ee4\u96c6\u7684\u7279\u6027\uff0c\u6307\u5bfc\u5e95\u5c42\u76f8\u5173\u4f18\u5316\u3002\u5b83\u4eec\u7684\u540d\u5b57\u90fd\u6bd4\u8f83\u76f4\u89c2\uff1a GPU: amdgpu nvgpu nvvm : NVVM IR for CUDA ARM: arm_neon arm_sve Intel: amx : The Intel Advanced Matrix Extensions x86vector","title":"\u5e95\u5c42\u5e73\u53f0\u76f8\u5173\u65b9\u8a00"}]}